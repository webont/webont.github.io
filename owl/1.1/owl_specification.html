<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <title>OWL 1.1 Web Ontology Language: Structural Specification and Functional-Style Syntax</title>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <link href="images/owl-icon.png" rel="shortcut icon">
  <link href="css/W3C-Member-SUBM.css" type="text/css" rel="stylesheet">
  <link href="css/owl.css" type="text/css" rel="stylesheet">
</head>
<body>

<div class="head">
<h1 class="mainTitle"><img style="float: right; height: 200px;" alt="owl" src="images/owl.png">OWL 1.1 Web Ontology Language<br>
Structural Specification and Functional-Style Syntax</h1>
<h2><a id="editordraft" name="editordraft"></a>Editor's Draft of 23 May 2007</h2>
<dl>
  <dt>This version:</dt>
  <dd><a href="http://www.webont.com/owl/1.1/owl_specification.html">http://www.webont.com/owl/1.1/owl_specification.html</a></dd>
  <dt>Latest version:</dt>
  <dd><a href="http://www.webont.com/owl/1.1/owl_specification.html">http://www.webont.com/owl/1.1/owl_specification.html</a></dd>
  <dt>Authors:</dt>
  <dd><a href="http://www.cs.man.ac.uk/~bmotik">Boris Motik</a>, The University of Manchester</dd> 
  <dd><a href="http://www.bell-labs.com/user/pfps/">Peter F. Patel-Schneider</a>, Bell Labs Research, Lucent Technologies</dd>
  <dd><a href="http://www.cs.man.ac.uk/~horrocks">Ian Horrocks</a>, The University of Manchester</dd>
</dl>
<p class=copyright>Copyright &copy; 2006-2007 by the Authors. This document is available under the
<a href="http://www.w3.org/Consortium/Legal/copyright-documents" shape=rect>W3C Document License</a>.
See the <a href="http://www.w3.org/Consortium/Legal/ipr-notice#Copyright" shape=rect>W3C Intellectual Rights Notice and Legal Disclaimers</a>
for additional information.</p>
<hr>
</div>

<div class="abstract">
<h2 class="notoc"><a id="abstract" name="abstract">Abstract</a></h2>
<p>OWL 1.1 extends the W3C OWL Web Ontology Language with a small but useful set of features 
that have been requested by users, for which effective reasoning algorithms are now available, 
and that OWL tool developers are willing to support. The new features include extra syntactic 
sugar, additional property and qualified cardinality constructors, extended datatype support, 
simple metamodelling, and extended annotations. This document defines a functional-style syntax 
for OWL 1.1, and provides an
informal discussion of the meaning of the additional constructs.</p>
</div>

<div class="status">
<h2 class="notoc"><a id="status" name="status">Status of this Document</a></h2>
<p><strong>This is an editor's draft, for comment by the OWL community.</strong></p>

<p>This document is an evolution of the 
<a href="http://www.w3.org/Submission/2006/SUBM-owl11-owl_specification-20061219/">OWL 1.1 Web Ontology Language: Structural 
Specification and Functional-Style Syntax</a> document that forms part of the 
<a href="http://www.w3.org/Submission/2006/10/">OWL 1.1 Web Ontology Language W3C Member Submission</a>.
Comments are welcome. Please send feedback to <a href="mailto:public-owl-dev@w3.org">public-owl-dev@w3.org</a>,
which has a <a href="http://lists.w3.org/Archives/Public/public-owl-dev/">public archive</a>. Bug reports
can be directed there. Please check the <a href="http://code.google.com/p/owl1-1/issues/list">issues list</a>
first.</p></div>
<hr>

<div class="toc">
<h2 class="notoc"><a id="toc" name="toc">Table of Contents</a></h2>

<ul class="toc">
  <li class="tocline1"><a href="#1">1 Introduction</a></li>
  <li class="tocline1"><a href="#2">2 Basic Definitions</a>
    <ul class="toc">
      <li class="tocline2"><a href="#2.1">2.1 Associations and Object Equivalence</a></li>
      <li class="tocline2"><a href="#2.2">2.2 URIs, Namespaces, and Integers</a></li>
    </ul>
  </li>
  <li class="tocline1"><a href="#3">3 Ontologies</a></li>
  <li class="tocline2"><a href="#4">4 The Concept Language</a>
    <ul class="toc">
      <li class="tocline2"><a href="#4.1">4.1 Entities</a></li>
      <li class="tocline2"><a href="#4.2">4.2 Object and Data Property Expressions</a></li>
      <li class="tocline2"><a href="#4.3">4.3 Data Ranges</a></li>
      <li class="tocline2"><a href="#4.4">4.4 Entity Annotations</a></li>
    </ul>
  </li>
  <li class="tocline1"><a href="#5">5 Classes</a></li>
  <li class="tocline1"><a href="#6">6 Axioms</a>
    <ul class="toc">
      <li class="tocline2"><a href="#6.1">6.1 Class Axioms</a></li>
      <li class="tocline2"><a href="#6.2">6.2 Object Property Axioms</a></li>
      <li class="tocline2"><a href="#6.3">6.3 Data Property Axioms</a></li>
      <li class="tocline2"><a href="#6.4">6.4 Facts</a></li>
    </ul>
  </li>
  <li class="tocline1"><a href="#7">7 Nonstructural Restrictions on Axioms</a></li>
  <li class="tocline1"><a href="#8">8 Declarations and Structural Consistency</a></li>
  <li class="tocline1"><a href="#A">Appendix A: Differences from OWL 1.0 Abstract Syntax</a>
    <ul class="toc">
      <li class="tocline2"><a href="#A.1">A.1 Parting with the Frame-Like Syntax</a></li>
      <li class="tocline2"><a href="#A.2">A.2 Inverse Property Expressions</a></li>
      <li class="tocline2"><a href="#A.3">A.3 Separating the Vocabulary for Names</a></li>
    </ul>
  </li>
  <li class="tocline1"><a href="#references">References</a></li>
</ul>
</div>

<hr>



<h2><a name="1"></a>1 Introduction</h2>

<p>This document defines the structure of Web Ontology Language
(OWL) 1.1. Unified Modeling Language (UML) class diagrams are used in order to make the definition precise.
The structure of OWL 1.1 ontologies is thus specified in a
structural way, by considering an ontology to be a collection of interconnected
objects. Moreover, since the structure of OWL 1.1 objects (ontologies, axioms, etc.)
is defined using well-understood notions of composition, sets, and lists,
it allows us to explicitly specify when two objects are structurally
equivalent.</p>

<p>Apart from a specification of the structure of OWL 1.1
ontologies, this document also defines a textual syntax for encoding
OWL 1.1 ontologies called the OWL 1.1 Functional-Style Syntax. The new syntax is similar
to the OWL 1.0 Abstract Syntax; it is, however, not backwards
compatible with the OWL 1.0 Abstract Syntax. The reason for this is that the OWL 1.0 Abstract Syntax syntax exhibits
several problems that would be very difficult to overcome without sacrificing
backwards compatibility.</p>



<h2><a name="2"></a>2 Basic Definitions</h2>

<p>The UML notation used in this document is restricted to a
very limited subset of UML class diagram notation. The names of
abstract classes (that is, the classes that are not intended to be instantiated)
are written in italic.</p>

<p>The grammar of OWL 1.1 is presented in the standard BNF notation. Nonterminal symbols
are written in bold (e.g., <span class="nonterminal">owlClassURI</span>), terminal
symbols are written in single quotes (e.g. <span class="name">'ObjectPropertyRange'</span>,
zero or more instances of a symbol is denoted with curly braces
(e.g., <span class="name">{ </span><span class="nonterminal">description</span><span class="name"> }</span>),
alternative productions are denoted with the vertical bar (e.g.,
<span class="nonterminal">fact</span><span class="name"> | </span><span class="nonterminal">declaration</span>),
and zero or one instances of a symbol are denoted with square brackets
(e.g., <span class="name">[ </span><span class="nonterminal">description</span><span class="name"> ]</span>).</p>

<h3><a name="2.1"></a>2.1 Associations and Object Equivalence</h3>

<p>Many associations between objects in OWL 1.1 ontologies are of one-to-many type; for example, an
<span class="name">ObjectUnionOf</span> class contains a
set of disjuncts. Usually, it is important to know whether the
objects in the association are ordered and whether repetitions
are allowed. This is made clear by attaching the following UML
stereotypes to associations between objects:</p>

<ul>

  <li>The <span class="name">&lt;&lt;set&gt;&gt;</span> stereotype denotes that the associated objects
  are unordered and that repetitions are not allowed.</li>

  <li>The <span class="name">&lt;&lt;list&gt;&gt;</span> stereotype denotes that the associated objects
  are ordered and that repetitions are allowed.</li>

</ul>

<p>To make this definition precise, it is necessary
to say when two objects are considered to be the same. This is captured by the
notion of <i>structural equivalence</i>, defined as follows.
Objects <span class="name">o<sub>1</sub></span> and <span class="name">o<sub>2</sub></span> are structurally
equivalent if the following conditions hold:</p>

<ul>

  <li>If <span class="name">o<sub>1</sub></span> and <span  class="name">o<sub>2</sub></span> are atomic values,
  such as strings, integers, or URI, they are structurally equivalent if they are the same.</li>

  <li>If <span class="name">o<sub>1</sub></span> and <span  class="name">o<sub>2</sub></span> are sets, they are
  structurally equivalent if each element of <span class="name">o<sub>1</sub></span>
  is structurally equivalent to some element of <span class="name">o<sub>2</sub></span>
  and vice versa.</li>

  <li>If <span class="name">o<sub>1</sub></span> and <span class="name">o<sub>2</sub></span> are lists, they are
  structurally equivalent if they contain the same number of elements and
  each element of <span class="name">o<sub>1</sub></span> is
  structurally equivalent to the element of <span class="name">o<sub>2</sub></span>
  with the same index.</li>

  <li>If <span class="name">o<sub>1</sub></span> and <span class="name">o<sub>2</sub></span> are complex objects
  composed of other objects, they are structurally equivalent if
    <ul>

      <li>both <span class="name">o<sub>1</sub></span> and <span class="name">o<sub>2</sub></span> are of the same type,</li>

      <li>each member of <span class="name">o<sub>1</sub></span> is structurally equivalent to the corresponding member of
      <span class="name">o<sub>2</sub></span>, and</li>

      <li>each association of <span class="name">o<sub>1</sub></span>
      is structurally equivalent to the corresponding association of <span class="name">o<sub>2</sub></span>.</li>

  </ul>
  </li>

</ul>

<p>For example, the description <span class="name">ObjectUnionOf( Person Animal )</span>
is structurally equivalent to description <span class="name">ObjectUnionOf( Animal Person )</span>
because the order of the elements in a set is not important.
Note that structural equivalence is not a semantic notion, as it is
based only on comparing object structures defined in this document. For example,
<span class="name">ObjectUnionOf( Person ObjectComplementOf( Person ) )</span>
is not structurally equivalent to <span class="name">owl:Thing</span>
even though it is semantically equivalent to it.</p>

<p>Although the <span class="name">&lt;&lt;set&gt;&gt;</span> stereotype is
widely used in the specification, ontology files written in one of the syntaxes
(e.g., XML or RDF/XML) are not expected to be duplicate free. Defining the structure of the
language in this way, however, facilitates the specification of APIs for 
manipulating OWL 1.1 ontologies programmatically; furthermore, it
provides the basis for the definition of complex operations on OWL 1.1 ontologies,
such as retraction of axioms.</p>

<h3><a name="2.2"></a>2.2 URIs, Namespaces, and Integers</h3>

<p>Ontologies and their elements are
identified using International Resource Identifiers (IRIs) that are
defined in [<cite><a href="#ref-rfc-3987">RFC-3987</a></cite>].
The syntax of full IRIs in OWL 1.1 is as follows:</p>

<p class="grammar">
  <span class="nonterminal">Full-IRI</span> := '&lt;' IRI as defined in [<cite><a href="#ref-rfc-3987">RFC-3987</a></cite>] '&gt;'
</p>

<p>For readability, IRIs can be abbreviated using namespaces.
The syntax in this case is the same as in the XML Namespaces specification
[<cite><a href="#ref-xml-namespaces">XML Namespaces</a></cite>]:</p>

<p class="grammar">
  <span class="nonterminal">Abbreviated-IRI</span> := <span class="nonterminal">QName</span> from the XML Namespaces specification<br>
  <span class="nonterminal">IRI-prefix</span> := as in XML Namespaces specification
</p>

<p>OWL 1.0 uses Uniform Resource Locators (URIs) to identify
objects. To avoid overloading the terminology, we use the term 'URI' in
OWL 1.1 to stay compatible with OWL 1.0; however, an URI is either a full IRI
or an abbreviated IRI:</p>

<p class="grammar">
  <span class="nonterminal">URI</span> := <span class="nonterminal">Full-IRI</span> | <span class="nonterminal">Abbreviated-IRI</span>
</p>

<p>Some grammar productions use numbers, which are defined as follows:</p>

<p class="grammar">
  <span class="nonterminal">zero</span> := '0'<br>
  <span class="nonterminal">nonZero </span>:= '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9'<br>
  <span class="nonterminal">digit</span> := <span class="nonterminal">zero</span> | <span class="nonterminal">nonZero</span><br>
  <span class="nonterminal">postiveInteger</span> := <span class="nonterminal">nonzero</span> { <span class="nonterminal">digit</span> }<br>
  <span class="nonterminal">nonNegativeInteger</span> := <span class="nonterminal">zero</span> | <span class="nonterminal">positiveInteger</span>
</p>

<p>The following standard namespace prefixes are used throughout this specification:</p>

<table border="1" cellspacing="0">
  <tbody>
    <tr>
      <th><a name="standard-namespaces">Namespace prefix</a></th>
      <th>Namespace</th>
    </tr>
    <tr>
      <td>rdf</td>
      <td>http://www.w3.org/1999/02/22-rdf-syntax-ns#</td>
    </tr>
    <tr>
      <td>rdfs</td>
      <td>http://www.w3.org/2000/01/rdf-schema#</td>
    </tr>
    <tr>
      <td>xsd</td>
      <td>http://www.w3.org/2001/XMLSchema#</td>
    </tr>
    <tr>
      <td>owl</td>
      <td>http://www.w3.org/2002/07/owl#</td>
    </tr>
    <tr>
      <td>owl11</td>
      <td>http://www.w3.org/2006/12/owl11#</td>
    </tr>
    <tr>
      <td>owl11xml</td>
      <td>http://www.w3.org/2006/12/owl11-xml#</td>
    </tr>
  </tbody>
</table>

<h2><a name="3"></a>3 Ontologies</h2>

<p>The structure of OWL 1.1 ontologies is shown in Figure 1. Each
ontology is uniquely identified with an ontology URI. This URI need not
be equal to the physical location of the ontology file. For example, a
file for an ontology with a URI <i>http://www.my.domain.com/example</i>
need not be physically stored in that location. A specification of a
mechanism for physically locating an ontology from its ontology URI is not in
scope of this specification.</p>

<p>The main component of an OWL 1.1 ontology is the set of axioms
that it contains. Note that this definition does not allow repetitions
of structurally equivalent axioms in an ontology. OWL 1.1 ontology files
are, however, not expected to enforce this and can simply eliminate duplicates.</p>

<p>Apart from a set of axioms, an OWL 1.1 ontology contains a
set of annotations. These can be used to associate information with an
ontology, such as the name of the ontology creator or the version of the
ontology. An annotation consists of an arbitrary annotation URI that specifies
the type of annotation and a constant specifying the value of the annotation.
OWL 1.1 allows for two kinds of annotation values:</p>

<ul>

  <li>Annotation values can be constants. Note that these need not be just
  strings; rather, any OWL 1.1 constant can be used. For example, one can
  create an annotation whose value is a URI formatted according to the
  XML Schema <i>xsd:anyURI</i> type specification.</li>

  <li>Annotation values can be ontology entities. Such annotations
  make it clearer that the value is not just some constant, but an entity
  from this or some other ontology.</li>

</ul>

<p>In OWL 1.0, <i>owl:imports</i> was a special annotation URI,
which denotes that an ontology imports another ontology. In OWL 1.1, imports
are not ontology annotations, but are a separate
primitive, as discussed next; the <i>owl:imports</i> annotation property
has no built-in meaning.</p>

<p>Each ontology contains a possibly empty set of <i>import declarations</i>. An ontology
<span class="name">O</span> <i>directly imports</i> an ontology <span  class="name">O'</span>
if <span class="name">O</span> contains an import declaration whose value is
the ontology URI of <span class="name">O'</span>. The relation <i>imports</i> is
defined as a transitive closure of the relation <i>directly imports</i>.
The <i>axiom closure</i> of an ontology <span class="name">O</span> is the smallest
set containing all the axioms of <span class="name">O</span> and of all
ontologies that <span class="name">O</span> imports. Intuitively, an import declaration
specification states that, when reasoning with an ontology <span class="name">O</span>,
one should consider not only the axioms of <span class="name">O</span>,
but the entire axiom closure of <span class="name">O</span>.</p>

<p class="image"><img src="images/spec/ontology.gif" border="0" alt="OWL Ontologies"><br>
<span class="caption">Figure 1.</span> OWL Ontologies</p>

<p>OWL 1.1 allows each axiom to contain annotations. These can be
used to associate arbitrary information with an axiom. This information
does not affect the semantics of the language in any way. For example, axiom
annotations could be used to associate information with each axiom
about who asserted the axiom. Since annotations are part of an axiom, they are to
be taken into account in the definition of structural equivalence of
axioms. For example, the axiom</p>

<p class="grammar">SubClassOf( Human Animal )</p>

<p>is not structurally equivalent to the axiom</p>

<p class="grammar">SubClassOf( Comment("Humans are a type of animals.") Human Animal)</p>

<p>even though the semantics of the two axioms is equivalent.</p>

<p>Annotations with the common URIs <i>rdfs:label</i> and <i>rdfs:comment</i> are abbreviated as follows:</p>

<p class="grammar">
  <span class="nonterminal">labelAnnotation</span> := 'Label' '(' <span class="nonterminal">constant</span> ')'<br>
  <span class="nonterminal">commentAnnotation</span> := 'Comment' '(' <span class="nonterminal">constant</span> ')'<br>
</p>

<p>All other annotations are written using the following grammar:</p>

<p class="grammar">
  <span class="nonterminal">annotationURI</span> := <span class="nonterminal">URI</span><br>
  <span class="nonterminal">explicitAnnotationByConstant</span> := 'Annotation' '(' <span class="nonterminal">annotationURI</span> <span class="nonterminal">constant</span>')'<br>
  <span class="nonterminal">annotationByConstant</span> := <span class="nonterminal">explicitAnnotationByConstant</span> | <span class="nonterminal">labelAnnotation</span> | <span class="nonterminal">commentAnnotation</span><br>
  <span class="nonterminal">annotationByEntity</span> := 'Annotation' '(' <span class="nonterminal">annotationURI</span> <span class="nonterminal">entity</span>')'<br>
  <span class="nonterminal">annotation</span> := <span class="nonterminal">annotationByConstant</span> | <span class="nonterminal">annotationByEntity</span>
</p>

<p>The syntax for OWL 1.1 ontology files is defined as follows:</p>

<p class="grammar">
  <span class="nonterminal">ontologyFile</span> :=&nbsp; <span lang="EN-GB">{ </span><span class="nonterminal">namespace</span> } <span class="nonterminal">ontology</span><br>
  <span class="nonterminal">namespace</span> := 'Namespace' '(' <span class="nonterminal">IRI-Prefix</span> '=' <span class="nonterminal">Full-IRI</span> ')'<br>
  <span class="nonterminal">ontology</span> := 'Ontology' '(' <span class="nonterminal">ontologyURI</span> { <span class="nonterminal">importDeclaration</span> } { <span class="nonterminal">annotation</span> } { <span class="nonterminal">axiom</span> } ')'<br>
  <span class="nonterminal">ontologyURI</span> := <span class="nonterminal">URI</span><br>
  <span class="nonterminal">importDeclaration</span> := 'Import' '(' <span class="nonterminal">URI</span> ')'<br>
  <span class="nonterminal">axiom</span> := <span class="nonterminal">classAxiom</span> | <span class="nonterminal">objectPropertyAxiom</span> | <span class="nonterminal">dataPropertyAxiom</span> | <span class="nonterminal">fact</span> | <span  class="nonterminal">declaration</span>  | <span  class="nonterminal">entityAnnotation</span>
</p>

<p>The <span class="nonterminal">namespace</span> production defines
an abbreviation for namespaces in a document. In each document,
only one namespace declaration can exist for a given
<span class="nonterminal">IRI-prefix</span>. These prefixes are then
used to expand abbreviated namespaces as specified in
the XML Namespaces specification [<cite><a href="#ref-xml-namespaces">XML Namespaces</a></cite>].</p>



<h2><a name="4"></a>4 The Concept Language</h2>

<p>We now define the concept language of OWL 1.1.</p>

<h3><a name="4.1"></a>4.1 Entities</h3>

<p>Entities are the fundamental building blocks of OWL 1.1
ontologies, and their hierarchy is shown in Figure 2.</p>

<p class="image"><img src="images/spec/c_entities.gif" border="0" alt="The Hierarchy of Entities in OWL 1.1"><br>
<span class="caption">Figure 2.</span> The Hierarchy of Entities in OWL 1.1</p>

<p>All entities are defined by a URI. The syntax for encoding entity URIs in OWL 1.1 is as follows:</p>

<p class="grammar">
  <span class="nonterminal">datatypeURI</span> :=<span class="nonterminal"> URI</span><br>
  <span class="nonterminal">owlClassURI</span> := <span class="nonterminal">URI</span><br>
  <span class="nonterminal">objectPropertyURI</span> := <span class="nonterminal">URI</span><br>
  <span class="nonterminal">dataPropertyURI</span> := <span class="nonterminal">URI</span><br>
  <span class="nonterminal">individualURI</span> := <span class="nonterminal">URI</span>
</p>

<p>Entities are encoded in the following way:</p>

<p class="grammar">
  <span class="nonterminal">entity</span> := <span class="nonterminal">datatype</span> | <span class="nonterminal">owlClass</span> | <span class="nonterminal">objectProperty</span> | <span class="nonterminal">dataProperty</span> | <span class="nonterminal">individual</span><br>
  <span class="nonterminal">datatype</span> := 'Datatype' '(' <span class="nonterminal">datatypeURI</span> ')'<br>
  <span class="nonterminal">owlClass</span> := 'OWLClass' '(' <span class="nonterminal">owlClassURI</span> ')'<br>
  <span class="nonterminal">objectProperty</span> := 'ObjectProperty' '(' <span class="nonterminal">objectPropertyURI</span> ')'<br>
  <span class="nonterminal">dataProperty</span> := 'DataProperty' '(' <span class="nonterminal">dataPropertyURI</span> ')'<br>
  <span class="nonterminal">individual</span> := 'Individual' '(' <span class="nonterminal">individualURI</span> ')'
</p>

<p>OWL 1.1 defines several well-known entities that have the predefined semantics. These entities are identified by the following predefined URIs:</p>

<ul>

  <li>A class with a URI <span class="name">owl:Thing</span> is the set of all objects.
  (In DL literature this is often called the top concept.)</li>

  <li>A class with a URI <span class="name">owl:Nothing</span> is the empty set of objects.
  (In DL literature this is often called the bottom concept.)</li>

  <li>A unary datatype with a URI <span class="name">rdfs:Literal</span> containing the set of all concrete objects.</li>

  <li>The datatypes with URIs as mentioned in [<cite><a href="#ref-owl-1.1-semantics">OWL 1.1 Semantics</a></cite>].</li>

</ul>


<p>OWL 1.1 uses constants to describe atomic values, such as
strings or integers. Constants consist of a string value optionally
followed by a datatype URI, as specified in the RDF specification
[<cite><a href="#ref-rdf-syntax">RDF Syntax</a></cite>]:</p>

<p class="grammar">
  <span class="nonterminal">string</span> := '"' a Unicode string in normal form C '"'<br>
  <span class="nonterminal">languageTag</span> := a language tag specified in [<cite><a href="#ref-rfc-3066">RFC-3066</a></cite>]<br>
  <span class="nonterminal">untypedConstant</span> := <span class="nonterminal">string</span> [ '@' <span class="nonterminal">languageTag</span> ]<br>
  <span class="nonterminal">typedConstant</span> := <span class="nonterminal">string</span> '^^' <span class="nonterminal">datatypeURI</span><br>
  <span class="nonterminal">constant</span> := <span class="nonterminal">typedConstant</span> | <span class="nonterminal">untypedConstant</span>
</p>

<p>All typed constants are required to be <i>well-formed</i> -- that is, the <span class="nonterminal">string</span> value
must be formatted as dictated by the rules for the datatype identified by <span class="nonterminal">datatypeURI</span>.
All untyped constants are well-formed by default.</p>

<h3><a name="4.2"></a>4.2 Object and Data Property Expressions</h3>

<p>Object properties can be combined into more complex expressions, as show
in Figure 3. In OWL 1.1, only inverse property expressions
are allowed. The
grammar for object property expressions is as follows:</p>

<p class="grammar">
  <span class="nonterminal">inverseObjectProperty</span> := 'InverseObjectProperty' '(' <span class="nonterminal">objectPropertyExpression</span> ')'<br>
  <span class="nonterminal">objectPropertyExpression</span> := <span class="nonterminal">objectPropertyURI</span> | <span class="nonterminal">inverseObjectProperty</span>
</p>

<p class="image"><img src="images/spec/c_objectproperty.gif" border="0" alt="Object Property Expressions"><br>
<span class="caption">Figure 3.</span> Object Property Expressions</p>

<p>For symmetry, OWL 1.1 also allows for data property expressions, as shown in Figure 4;
the only type of data property expressions are, however, data properties. The grammar
for data property expressions is as follows:</p>

<p class="grammar">
  <span class="nonterminal">dataPropertyExpression</span> := <span class="nonterminal">dataPropertyURI</span>
</p>

<p class="image"><img src="images/spec/c_dataproperty.gif" border="0" alt="Data Property Expressions"><br>
<span class="caption">Figure 4.</span> Data Property Expressions</p>

<h3><a name="4.3"></a>4.3 Data Ranges</h3>

<p>OWL 1.1 provides several ways to define a range over data
values, as shown in Figure 5. A <span class="nonterminal">datatype</span>
is a fundamental type of data range that is defined by a URI. Each datatype URI
is associated with a predefined arity (note that the same datatype URI cannot
be used with different arities). The list of the datatypes supported in OWL 1.1
is given in [<cite><a href="#ref-owl-1.1-semantics">OWL 1.1 Semantics</a></cite>];
furthermore, this list can be extended by implementations as needed. The meanining
of OWL 1.1 ontologies containing a datatype URI not supported by an implementation
is not defined by this specification; the implementations are allowed to signal an
error in this case.</p>

<p>Complex data ranges can be constructed from the simpler ones
using the <span class="nonterminal">dataComplementOf</span> constructor,
which takes a data range and returns its complement (with the same arity),
Furthermore, data ranges consisting exactly of the specified set of
constants can be formed using the <span class="nonterminal">dataOneOf</span>
constructor (and it has the arity one). Finally, the <span class="nonterminal">datatypeRestriction</span>
constructor creates a data range by applying a facet to a particular data range. A restriction
consists of a constant restriction value and a facet type that is applied to the
data range in question. The following facet types are supported in OWL 1.1:
<i>length</i>, <i>minLength</i>, <i>maxLength</i>, <i>pattern</i>, <i>minInclusive</i>, <i>minExclusive</i>,
<i>maxInclusive</i>, <i>maxExclusive</i>, <i>totalDigits</i>, and <i>fractionDigits</i>.
The semantics of the facets is defined in the XML Schema Datatypes Specification
[<cite><a href="#ref-xml-schema-datatypes">XML Schema Datatypes</a></cite>].</p>

<p class="image"><img src="images/spec/c_datarange.gif" border="0" alt="Data Ranges of OWL 1.1"><br>
<span class="caption">Figure 5.</span> Data Ranges of OWL 1.1</p>

<p>The grammar for OWL 1.1 data ranges is as follows:</p>

<p class="grammar">
  <span class="nonterminal">dataComplementOf</span> := 'DataComplementOf' '(' <span class="nonterminal">dataRange</span> ')'<br>
  <span class="nonterminal">dataOneOf</span> := 'DataOneOf' '(' <span class="nonterminal">constant</span> { <span class="nonterminal">constant</span> } ')'<br>
  <span class="nonterminal">datatypeFacet</span> :=<br>
  &nbsp;&nbsp;&nbsp;'length' | 'minLength' | 'maxLength' | 'pattern' |<br>
  &nbsp;&nbsp;&nbsp; 'minInclusive' | 'minExclusive' | 'maxInclusive' | 'maxExclusive' |<br>
  &nbsp;&nbsp;&nbsp; 'totalDigits' | 'fractionDigits'<br>
  <span class="nonterminal">restrictionValue</span> := <span class="nonterminal">constant</span><br>
  <span class="nonterminal">datatypeRestriction</span> := 'DatatypeRestriction' '(' <span class="nonterminal">dataRange</span> <span class="nonterminal">datatypeFacet</span> <span class="nonterminal">restrictionValue</span> ')'<br>
  <span class="nonterminal">dataRange</span> := <span class="nonterminal">datatypeURI</span> | <span class="nonterminal">dataComplementOf</span> | <span class="nonterminal">dataOneOf</span> | <span class="nonterminal">datatypeRestriction</span>
</p>

<h3><a name="4.4"></a>4.4 Entity Annotations</h3>

<p>Often, it is desirable to annotate entities in an ontology; such an annotation might,
for example, specify a "human-friendly" label or comment. OWL 1.1 provides entity annotations
for this purpose; their structure is shown in Figure 6.</p>

<p class="image"><img src="images/spec/a_entityannotation.gif" border="0" alt="Entity Annotations in OWL 1.1"><br>
<span class="caption">Figure 6.</span> Entity Annotations in OWL 1.1</p>

<p>Note that an entity annotation axiom provides for two types of
annotation -- one for the axiom itself and
one for the entity. It is important to distinguish these two
types of annotation: the first one refers to the axiom (e.g.,
says who has asserted it), whereas the second one refers to the
entity itself (e.g., provides a human-friendly label). The grammar for
entity annotations is as follows:</p>

<p class="grammar">
  <span class="nonterminal">annotationsForAxiom</span> := <span class="nonterminal">annotation</span><br>
  <span class="nonterminal">annotationsForEntity</span> := <span class="nonterminal">annotation</span><br>
  <span class="nonterminal">entityAnnotation</span> := 'EntityAnnotation' '(' { <span class="nonterminal">annotationsForAxiom</span> } <span class="nonterminal">entity</span> { <span class="nonterminal">annotationsForEntity</span> } ')'
</p>

<p>Note that the production for the <span class="nonterminal">entityAnnotation</span>
nonterminal requires an <span class="nonterminal">entity</span> and
not a URI. Thus, an OWL class should be annotated as follows:</p>

<p class="grammar">
  EntityAnnotation(OWLClass(Person) Comment("The set of all humans."))
</p>

<p>This is so that the type of the entity being annotated can easily be determined from the syntactic form
of the entity annotation axiom.</p>




<h2><a name="5"></a>5 Classes</h2>

<p>OWL 1.1 provides an expressive language for forming classes.
For clarity, these are presented in three separate diagrams. The propositional
connectives are presented in Figure 7. The class <span class="nonterminal">objectUnionOf</span>
is a disjunction of a set of classes, <span class="nonterminal">objectIntersectionOf</span>
is a conjunction of a set of classes, <span class="nonterminal">objectComplementOf</span>
is a negation of a class, and <span class="nonterminal">objectOneOf</span>
is a class that contains exactly the objects denoted by the set of specified individuals. The
grammar for the propositional classes is defined as follows:</p>

<p class="grammar">
  <span class="nonterminal">objectUnionOf</span> := 'ObjectUnionOf' '(' <span class="nonterminal">description</span> <span class="nonterminal">description</span> { <span class="nonterminal">description</span> } ')'<br>
  <span class="nonterminal">objectIntersectionOf</span> := 'ObjectIntersectionOf' '(' <span class="nonterminal">description</span> <span class="nonterminal">description</span> { <span class="nonterminal">description</span> } ')'<br>
  <span class="nonterminal">objectComplementOf</span> := 'ObjectComplementOf' '(' <span class="nonterminal">description</span> ')'<br>
  <span class="nonterminal">objectOneOf</span> := 'ObjectOneOf' '(' <span class="nonterminal">individualURI</span> { <span class="nonterminal">individualURI</span> }')'<br>
</p>

<p class="image"><img src="images/spec/c_propositional.gif" border="0" alt="Propositional Connectives for the Formation of Classes"><br>
<span class="caption">Figure 7.</span> Propositional Connectives for the Formation of Classes</p>

<p>OWL 1.1 also allows classes to be defined by means of restrictions on
object properties, as shown in Figure 8. The class <span class="nonterminal">objectAllValuesFrom</span>
denotes the set of objects that are connected via the given object property only to
instances of the given class, <span class="nonterminal">objectSomeValuesFrom</span> denotes the set of
objects that are connected via the given object property to at least one instance of the
given class, <span class="nonterminal">objectExistsSelf</span> denotes the
set of objects that are connected to themselves via the given object property,
and <span class="nonterminal">objectHasValue</span> denotes the
set of objects that are connected via the given object property to the object denoted by the given individual.
The grammar for the restrictions is as follows:</p>

<p class="grammar">
  <span class="nonterminal">objectAllValuesFrom</span> := 'ObjectAllValuesFrom' '(' <span class="nonterminal">objectPropertyExpression</span> <span class="nonterminal">description</span> ')'<br>
  <span class="nonterminal">objectSomeValuesFrom</span> := 'ObjectSomeValuesFrom' '(' <span class="nonterminal">objectPropertyExpression</span> <span  class="nonterminal">description</span> ')'<br>
  <span class="nonterminal">objectExistsSelf</span> := 'ObjectExistsSelf' '(' <span class="nonterminal">objectPropertyExpression</span> ')'<br>
  <span class="nonterminal">objectHasValue</span> := 'ObjectHasValue' '(' <span class="nonterminal">objectPropertyExpression</span> <span class="nonterminal">individualURI</span> ')'
</p>

<p class="image"><img src="images/spec/c_objectmodal.gif" border="0" alt="OWL 1.1 Classes Defined by Restriction on Object Properties"><br>
<span class="caption">Figure 8.</span> OWL 1.1 Classes Defined by Restriction on Object Properties</p>

<p>Finally, OWL 1.1 classes can be defined by restricting the
cardinality of associations between objects, as shown in Figure 9.
Cardinality restrictions can be qualified or unqualified, depending on whether
there is a restriction on the class of the connected individual; an unqualified cardinality restriction is equivalent to a qualified one where the restricting class is <span class="name">owl:Thing</span>. The class <span class="nonterminal">objectMinCardinality</span>
denotes the set of objects that are connected via the given object property to
at least the given number of instances of the given class, the class <span class="nonterminal">objectMaxCardinality</span>
denotes the set of objects that are connected via the given object property to
at most the given number of instances of the given class, and the class <span class="nonterminal">objectExactCardinality</span>
denotes the set of objects that are connected via the given object property to
exactly the given number of instances of the given class.
The grammar for
these restrictions is defined as follows:</p>

<p class="grammar">
  <span class="nonterminal">cardinality</span> := <span class="nonterminal">nonNegativeInteger</span><br>
  <span class="nonterminal">objectMinCardinality</span> := 'ObjectMinCardinality' '(' <span class="nonterminal">cardinality</span> <span class="nonterminal">objectPropertyExpression</span> [ <span class="nonterminal">description</span> ] ')'<br>
  <span class="nonterminal">objectMaxCardinality</span> := 'ObjectMaxCardinality' '(' <span class="nonterminal">cardinality</span> <span  class="nonterminal">objectPropertyExpression</span> [ <span class="nonterminal">description</span> ] ')'<br>
  <span class="nonterminal">objectExactCardinality</span> := 'ObjectExactCardinality' '(' <span class="nonterminal">cardinality</span> <span class="nonterminal">objectPropertyExpression</span> [ <span  class="nonterminal">description</span> ] ')'
</p>

<p class="image"><img src="images/spec/c_objectcardinality.gif" border="0" alt="OWL 1.1 Classes Defined by Restricting Object Property Cardinalities"><br>
<span class="caption">Figure 9.</span> OWL 1.1 Classes Defined by Restricting Object Property Cardinalities</p>

<p>OWL 1.1 also allows for the definition of classes by
stating restrictions on data properties, as shown in Figure 10. The
notable distinction with respect to object property restrictions is that <span class="nonterminal">dataAllValuesFrom</span>
and <span class="nonterminal">dataSomeValuesFrom</span> restrictions
take a list of data property expressions, and not just a single property expression.
This is in order to support class definitions such as "objects whose width is greater
than their height", where the values of width and height are specified using two data properties. In such definitions, the arity of the given data range must be equal
to the number of the given data properties.</p>

<p class="image"><img src="images/spec/c_datamodal.gif" border="0" alt="OWL 1.1 Classes Defined by Restriction on Data Properties"><br>
<span class="caption">Figure 10.</span> OWL 1.1 Classes Defined by Restriction on Data Properties</p>

<p>Figure 11 shows the restrictions that can be built by
stating cardinality restrictions on data properties. If the data range
is supplied, its arity must be one.</p>

<p class="image"><img src="images/spec/c_datacardinality.gif" border="0" alt="OWL 1.1 Classes Defined by Restriction on Data Properties"><br>
<span class="caption">Figure 11.</span> OWL 1.1 Classes Defined by Restriction on Data Properties</p>

<p>The grammar for restrictions on data properties is defined as follows:</p>

<p class="grammar">
  <span class="nonterminal">dataAllValuesFrom</span> := 'DataAllValuesFrom' '(' <span class="nonterminal">dataPropertyExpression</span> { <span class="nonterminal">dataPropertyExpression</span> } <span class="nonterminal">dataRange</span> ')'<br>
  <span class="nonterminal">dataSomeValuesFrom</span> := 'DataSomeValuesFrom' '(' <span class="nonterminal">dataPropertyExpression</span> { <span class="nonterminal">dataPropertyExpression</span> } <span class="nonterminal">dataRange</span> ')'<br>
  <span class="nonterminal">dataHasValue</span> := 'DataHasValue' '(' <span class="nonterminal">dataPropertyExpression</span> <span class="nonterminal">constant</span> ')'<br>
  <span class="nonterminal">dataMinCardinality</span> := 'DataMinCardinality' '(' <span class="nonterminal">cardinality</span> <span class="nonterminal">dataPropertyExpression</span> [ <span class="nonterminal">dataRange</span> ] ')'<br>
  <span class="nonterminal">dataMaxCardinality</span> := 'DataMaxCardinality' '(' <span class="nonterminal">cardinality</span> <span class="nonterminal">dataPropertyExpression</span> [ <span class="nonterminal">dataRange</span> ] ')'<br>
  <span class="nonterminal">dataExactCardinality</span> := 'DataExactCardinality' '(' <span class="nonterminal">cardinality</span> <span class="nonterminal">dataPropertyExpression</span> [ <span class="nonterminal">dataRange</span> ] ')'
</p>

<p>The following grammar production integrates all types of classes in OWL 1.1:</p>

<p class="grammar">
  <span class="nonterminal">description</span> := <span class="nonterminal">owlClassURI</span> | <span class="nonterminal">objectUnionOf</span> | <span class="nonterminal">objectIntersectionOf</span> | <span class="nonterminal">objectComplementOf</span> | <span class="nonterminal">objectOneOf</span> |<br>
  &nbsp;&nbsp;&nbsp; <span class="nonterminal">objectAllValuesFrom</span> | <span class="nonterminal">objectSomeValuesFrom</span> | <span class="nonterminal">objectExistsSelf</span> | <span class="nonterminal">objectHasValue</span> |<br>
  &nbsp;&nbsp;&nbsp; <span class="nonterminal">objectMinCardinality</span> | <span class="nonterminal">objectMaxCardinality</span> | <span class="nonterminal">objectExactCardinality</span> |<br>
  &nbsp;&nbsp;&nbsp; <span class="nonterminal">dataAllValuesFrom</span> | <span class="nonterminal">dataSomeValuesFrom</span> | <span class="nonterminal">dataHasValue</span> |<br>
  &nbsp;&nbsp;&nbsp; <span class="nonterminal">dataMinCardinality</span> | <span class="nonterminal">dataMaxCardinality</span> | <span class="nonterminal">dataExactCardinality</span>
</p>



<h2><a name="6"></a>6 Axioms</h2>

<p>This section lists the types of axiom that can be stated in
OWL 1.1. To make the presentation easier to follow, the axioms are
grouped by type. As already mentioned, an axiom may contain an
arbitrary number of annotations; furthermore, although annotations
do not affect the semantics of an axiom, they are taken into account
in the definition of structural equivalence.</p>

<h3><a name="6.1"></a>6.1 Class Axioms</h3>

<p>The class axioms of OWL 1.1 are shown in Figure 12. The
<span class="nonterminal">subClassOf</span> axiom states that
one class is a subclass of another class. The
<span class="nonterminal">equivalentClasses</span> axiom
takes a set of classes and states that they are all equivalent. The <span class="nonterminal">disjointClasses</span> axiom
takes a set of classes and states that all classes from the set are pair-wise
disjoint. Finally, the <span class="nonterminal">disjointUnion</span> axiom
defines a class as a union of other classes, all of which are pair-wise disjoint.
The grammar for the class axioms of OWL 1.1 is as follows.</p>

<p class="grammar">
  <span class="nonterminal">subClass</span> := <span class="nonterminal">description</span><br>
  <span class="nonterminal">superClass</span> := <span class="nonterminal">description</span><br>
  <span class="nonterminal">subClassOf</span> := 'SubClassOf' '(' { <span class="nonterminal">annotation</span> } <span class="nonterminal">subClass</span> <span class="nonterminal">superClass</span> ')'<br>
  <span class="nonterminal">equivalentClasses</span> := 'EquivalentClasses' '(' { <span class="nonterminal">annotation</span> } <span class="nonterminal">description</span> <span class="nonterminal">description</span> { <span class="nonterminal">description</span> } ')'<br>
  <span class="nonterminal">disjointClasses</span> := 'DisjointClasses' '(' { <span class="nonterminal">annotation</span> } <span class="nonterminal">description</span> <span class="nonterminal">description</span> { <span class="nonterminal">description</span> } ')'<br>
  <span class="nonterminal">disjointUnion</span> := 'DisjointUnion' '(' { <span class="nonterminal">annotation</span> } <span class="nonterminal">owlClassURI</span> <span class="nonterminal">description</span> <span class="nonterminal">description</span> { <span class="nonterminal">description</span> } ')'<br>
  <span class="nonterminal">classAxiom</span> := <span class="nonterminal">subClassOf</span> | <span class="nonterminal">equivalentClasses</span> | <span class="nonterminal">disjointClasses</span> | <span class="nonterminal">disjointUnion</span>
</p>

<p class="image"><img src="images/spec/a_classes.gif" border="0" alt="The Class Axioms of OWL 1.1"><br>
<span class="caption">Figure 12.</span> The Class Axioms of OWL 1.1</p>

<h3><a name="6.2"></a>6.2 Object Property Axioms</h3>

<p>OWL 1.1 provides for several different kinds of object property axioms. For clarity these are presented in two separate diagrams,
the first of which is Figure 13. The
<span  class="nonterminal">equivalentObjectProperties</span> axiom takes a set of object properties and states
that they are all equivalent, and the <span class="nonterminal">disjointObjectProperties</span> axiom takes a
set of object properties and states that all properties from the set are pair-wise disjoint. Furthermore,
<span class="nonterminal">objectPropertyDomain</span> and
<span class="nonterminal">objectPropertyRange</span> specify the domain and
the range class, respectively, of an object property.
Finally, <span class="nonterminal">inverseObjectProperties</span>
axiomatizes two properties to be inverse of each other.
These axioms are described using the following grammar:</p>

<p class="grammar">
  <span class="nonterminal">subObjectPropertyExpression</span> := <span class="nonterminal">objectPropertyExpression</span> | 'SubObjectPropertyChain' '(' <span class="nonterminal">objectPropertyExpression</span> <span class="nonterminal">objectPropertyExpression</span> { <span class="nonterminal">objectPropertyExpression</span> } ')'<br>
  <span class="nonterminal">subObjectPropertyOf</span> := 'SubObjectPropertyOf' '(' { <span class="nonterminal">annotation</span> } <span class="nonterminal">subObjectPropertyExpression</span> <span class="nonterminal">objectPropertyExpression</span> ')'<br>
  <span class="nonterminal">equivalentObjectProperties</span> := 'EquivalentObjectProperties' '(' { <span class="nonterminal">annotation</span> } <span class="nonterminal">objectPropertyExpression</span> <span class="nonterminal">objectPropertyExpression</span> { <span class="nonterminal">objectPropertyExpression</span> } ')'<br>
  <span class="nonterminal">disjointObjectProperties</span> := 'DisjointObjectProperties' '(' { <span class="nonterminal">annotation</span> } <span class="nonterminal">objectPropertyExpression</span> <span class="nonterminal">objectPropertyExpression</span> { <span class="nonterminal">objectPropertyExpression</span> } ')'<br>
  <span class="nonterminal">objectPropertyDomain</span> := 'ObjectPropertyDomain' '(' { <span class="nonterminal">annotation</span> } <span class="nonterminal">objectPropertyExpression</span> <span class="nonterminal">description</span> ')'<br>
  <span class="nonterminal">objectPropertyRange</span> := 'ObjectPropertyRange' '(' { <span class="nonterminal">annotation</span> } <span class="nonterminal">objectPropertyExpression</span> <span class="nonterminal">description</span> ')'<br>
  <span class="nonterminal">inverseObjectProperties</span> := 'InverseObjectProperties' '(' { <span class="nonterminal">annotation</span> } <span class="nonterminal">objectPropertyExpression</span> <span class="nonterminal">objectPropertyExpression</span> ')'
</p>

<p class="image"><img src="images/spec/a_objectproperty1.gif" border="0" alt="Object Property Axioms, Part I"><br>
<span class="caption">Figure 13.</span> Object Property Axioms, Part I</p>

<p>In addition, OWL 1.1 provides for axioms that allow the
assertion of various characteristics of an object property, as specified in
Figure 14. Each of these axioms takes an object property and asserts that the property
has a certain characteristic, such as being functional or transitive. These
axioms are described by the following grammar:</p>

<p class="grammar">
  <span class="nonterminal">functionalObjectProperty</span> := 'FunctionalObjectProperty' '(' { <span class="nonterminal">annotation</span> } <span class="nonterminal">objectPropertyExpression</span> ')'<br>
  <span class="nonterminal">inverseFunctionalObjectProperty</span> := 'InverseFunctionalObjectProperty' '(' { <span class="nonterminal">annotation</span> } <span class="nonterminal">objectPropertyExpression</span> ')'<br>
  <span class="nonterminal">reflexiveObjectProperty</span> := 'ReflexiveObjectProperty' '(' { <span class="nonterminal">annotation</span> } <span class="nonterminal">objectPropertyExpression</span> ')'<br>
  <span class="nonterminal">irreflexiveObjectProperty</span> := 'IrreflexiveObjectProperty' '(' { <span class="nonterminal">annotation</span> } <span class="nonterminal">objectPropertyExpression</span> ')'<br>
  <span class="nonterminal">symetricObjectProperty</span> := 'SymmetricObjectProperty' '(' { <span class="nonterminal">annotation</span> } <span class="nonterminal">objectPropertyExpression</span> ')'<br>
  <span class="nonterminal">asymetricObjectProperty</span> := 'AsymmetricObjectProperty' '(' { <span class="nonterminal">annotation</span> } <span class="nonterminal">objectPropertyExpression</span> ')'<br>
  <span class="nonterminal">transitiveObjectProperty</span> := 'TransitiveObjectProperty' '(' { <span class="nonterminal">annotation</span> } <span class="nonterminal">objectPropertyExpression</span> ')'
</p>

<p class="image"><img src="images/spec/a_objectproperty2.gif" border="0" alt="Axioms Defining Characteristics of Object Properties, Part II"><br>
<span class="caption">Figure 14.</span> Axioms Defining Characteristics of Object Properties, Part II</p>

<p>The following grammar production merges all productions for object property axioms:</p>

<p class="grammar">
  <span class="nonterminal">objectPropertyAxiom</span> :=<br>
  &nbsp;&nbsp;&nbsp; <span class="nonterminal">subObjectPropertyOf</span> | <span class="nonterminal">equivalentObjectProperties</span> |<br>
  &nbsp;&nbsp;&nbsp; <span class="nonterminal">disjointObjectProperty</span> | <span class="nonterminal">inverseObjectProperties</span> |<br>
  &nbsp;&nbsp;&nbsp; <span class="nonterminal">objectPropertyDomain</span> | <span class="nonterminal">objectPropertyRange</span> |<br>
  &nbsp;&nbsp;&nbsp; <span class="nonterminal">functionalObjectProperty</span> | <span class="nonterminal">inverseFunctionalObjectProperty</span> |<br>
  &nbsp;&nbsp;&nbsp; <span class="nonterminal">reflexiveObjectProperty</span> | <span class="nonterminal">irreflexiveObjectProperty</span> |<br>
  &nbsp;&nbsp;&nbsp; <span class="nonterminal">symetricObjectProperty</span> | <span class="nonterminal">asymetricObjectProperty</span> |<br>
  &nbsp;&nbsp;&nbsp; <span class="nonterminal">transitiveObjectProperty</span>
</p>

<h3><a name="6.3"></a>6.3 Data Property Axioms</h3>

<p>Data property axioms are similar to object property
axioms, and are shown in Figure 15. Note that the
arity of the data range used in a <span class="nonterminal">dataPropertyRange</span>
axiom must be one. The axioms are described by the following grammar:</p>

<p class="grammar">
  <span class="nonterminal">subDataPropertyOf</span> := 'SubDataPropertyOf' '(' { <span class="nonterminal">annotation</span> } <span class="nonterminal">dataPropertyExpression</span> <span class="nonterminal">dataPropertyExpression</span> ')'<br>
  <span class="nonterminal">equivalentDataProperties</span> := 'EquivalentDataProperties' '(' { <span class="nonterminal">annotation</span> } <span class="nonterminal">dataPropertyExpression</span> <span class="nonterminal">dataPropertyExpression</span> { <span class="nonterminal">dataPropertyExpression</span> } ')'<br>
  <span class="nonterminal">disjointDataProperties</span> := 'DisjointDataProperties' '(' { <span class="nonterminal">annotation</span> } <span class="nonterminal">dataPropertyExpression</span> <span class="nonterminal">dataPropertyExpression</span> { <span class="nonterminal">dataPropertyExpression</span> } ')'<br>
  <span class="nonterminal">dataPropertyDomain</span> := 'DataPropertyDomain' '(' { <span class="nonterminal">annotation</span> } <span class="nonterminal">dataPropertyExpression</span> <span class="nonterminal">description</span> ')'<br>
  <span class="nonterminal">dataPropertyRange</span> := 'DataPropertyRange' '(' { <span class="nonterminal">annotation</span> } <span class="nonterminal">dataPropertyExpression</span> <span class="nonterminal">dataRange</span> ')'<br>
  <span class="nonterminal">functionalDataProperty</span> := 'FunctionalDataProperty' '(' { <span class="nonterminal">annotation</span> } <span class="nonterminal">dataPropertyExpression</span> ')'
</p>

<p class="image"><img src="images/spec/a_dataproperty.gif" border="0" alt="Data Property Axioms of OWL 1.1"><br>
<span class="caption">Figure 15.</span> Data Property Axioms of OWL 1.1</p>

<p>The following grammar production merges all productions for data property axioms:</p>

<p class="grammar">
  <span class="nonterminal">dataPropertyAxiom</span> :=<br>
  &nbsp;&nbsp;&nbsp; <span class="nonterminal">subDataPropertyOf</span> | <span class="nonterminal">equivalentDataProperties</span> | <span class="nonterminal">disjointDataProperties</span> |<br>
  &nbsp;&nbsp;&nbsp; <span class="nonterminal">dataPropertyDomain</span> | <span class="nonterminal">dataPropertyRange</span> | <span class="nonterminal">functionalDataProperty</span>
</p>

<h3><a name="6.4"></a>6.4 Facts</h3>

<p>OWL 1.1 supports a rich set of axioms for stating facts. Figure 16
shows the facts that can be stated about individuals and classes.
The <span class="nonterminal">sameIndividual</span> axiom states that
each of the individuals from a given set denotes the same object, whereas the
<span class="nonterminal">differentIndividuals</span> axiom states that
each of the individuals from a given set denotes a different object.
The <span class="nonterminal">classAssertion</span> axiom states that the object
denoted by the given individual is an instance of the given class. The grammar for these axioms
is as follows:</p>

<p class="grammar">
  <span class="nonterminal">sameIndividual</span> := 'SameIndividual' '(' { <span class="nonterminal">annotation</span> } <span class="nonterminal">individualURI</span> <span class="nonterminal">individualURI</span> { <span class="nonterminal">individualURI</span> } ')'<br>
  <span class="nonterminal">differentIndividuals</span> := 'DifferentIndividuals' '(' { <span class="nonterminal">annotation</span> } <span class="nonterminal">individualURI</span> <span class="nonterminal">individualURI</span> { <span class="nonterminal">individualURI</span> } ')'<br>
  <span class="nonterminal">classAssertion</span> := 'ClassAssertion' '(' { <span class="nonterminal">annotation</span> } <span class="nonterminal">individualURI</span> <span class="nonterminal">description</span> ')'
</p>

<p class="image"><img src="images/spec/a_abox1.gif" border="0" alt="Class and Individual Assertions"><br>
<span class="caption">Figure 16.</span> Class and Individual Assertions</p>

<p>The facts about object properties are shown in Figure 17.
The <span class="nonterminal">objectPropertyAssertion</span> states
that the objects denoted by the given individuals are connected by the given property, whereas the
<span class="nonterminal">negativeObjectPropertyAssertion</span> states that
the objects denoted by the given individuals are not connected by the given property. The grammar for
these axioms is as follows:</p>

<p class="grammar">
  <span class="nonterminal">sourceIndividualURI</span> := <span class="nonterminal">individualURI</span><br>
  <span class="nonterminal">targetIndividualURI</span> := <span class="nonterminal">individualURI</span><br>
  <span class="nonterminal">objectPropertyAssertion</span> := 'ObjectPropertyAssertion' '(' { <span class="nonterminal">annotation</span> } <span class="nonterminal">objectPropertyExpression</span> <span class="nonterminal">sourceIndividualURI</span> <span class="nonterminal">targetIndividualURI</span> ')'<br>
  <span class="nonterminal">negativeObjectPropertyAssertion</span> := 'NegativeObjectPropertyAssertion' '(' { <span class="nonterminal">annotation</span> } <span class="nonterminal">objectPropertyExpression</span> <span class="nonterminal">sourceIndividualURI</span> <span class="nonterminal">targetIndividualURI</span> ')'
</p>

<p class="image"><img src="images/spec/a_abox3.gif" border="0" alt="Object Property Assertions"><br>
<span class="caption">Figure 17.</span> Object Property Assertions</p>

<p>The structure of axioms asserting facts about data properties
is similar and is shown in Figure 18. The <span class="nonterminal">dataPropertyAssertion</span>
states that the value of a data property for an object denoted by the given individual is the
given constant, whereas the <span class="nonterminal">negativeDataPropertyAssertion</span>
states the opposite. The grammar is as follows:</p>

<p class="grammar">
  <span class="nonterminal">targetValue</span> := <span class="nonterminal">constant</span><br>
  <span class="nonterminal">dataPropertyAssertion</span> := 'DataPropertyAssertion' '(' { <span class="nonterminal">annotation</span> } <span class="nonterminal">dataPropertyExpression</span> <span class="nonterminal">sourceIndividualURI</span> <span class="nonterminal">targetValue</span> ')'<br>
  <span class="nonterminal">negativeDataPropertyAssertion</span> := 'NegativeDataPropertyAssertion' '(' { <span class="nonterminal">annotation</span> } <span class="nonterminal">dataPropertyExpression</span> <span class="nonterminal">sourceIndividualURI</span> <span class="nonterminal">targetValue</span> ')'
</p>

<p class="image"><img src="images/spec/a_abox2.gif" border="0" alt="Data Property Assertions"><br>
<span class="caption">Figure 18.</span> Data Property Assertions</p>

<p>The following production integrates all types of facts:</p>

<p class="grammar">
  <span class="nonterminal">fact</span> := <span class="nonterminal">sameIndividual</span> | <span class="nonterminal">differentIndividuals</span> | <span class="nonterminal">classAssertion</span> |<br>
  &nbsp;&nbsp;&nbsp; <span class="nonterminal">objectPropertyAssertion</span> | <span class="nonterminal">negativeObjectPropertyAssertion</span> |<br>
  &nbsp;&nbsp;&nbsp; <span class="nonterminal">dataPropertyAssertion</span> | <span class="nonterminal">negativeDataPropertyAssertion</span>
</p>



<h2><a name="7"></a>7 Nonstructural Restrictions on Axioms</h2>

<p>As explained in [<cite><a href="#ref-sroiq">SROIQ</a></cite>], to obtain a decidable
language, the axiom closure <span class="name">Ax</span> of each OWL 1.1 ontology must
obey certain <i>nonstructural restrictions</i>, as defined next. In this section, we assume that
all object property expressions in <span class="name">Ax</span> are either object properties
or inverses of an object property. This can be ensured by replacing all expressions
<span class="name">InverseObjectProperty( InverseObjectProperty(PE) )</span>
with <span class="name">PE</span>.</p>

<p>For an object property expression <span class="name">PE</span>, the <i>inverse property expression</i>
<span class="name">INV(PE)</span> is defined as follows:</p>

<ul>

  <li>if <span class="name">PE</span> is an object property <span class="name">OP</span>,
  then <span class="name">INV(PE) = InverseObjectProperty(OP)</span>;</li>

  <li>if <span class="name">PE</span> is of the form <span class="name">InverseObjectProperty(OP)</span> for
  <span class="name">OP</span> an object property, then <span class="name">INV(PE) = OP</span>.</li>

</ul>

<p>An object property expression <span class="name">PE</span> is <i>composite</i> in <span class="name">Ax</span> if
<span class="name">Ax</span> contains an axiom of the form</p>

<ul>

  <li><span class="name">SubObjectPropertyOf(SubObjectPropertyChain(PE<sub>1</sub> ... PE<sub>n</sub>) PE)</span> with n > 1, or</li>

  <li><span class="name">SubObjectPropertyOf(SubObjectPropertyChain(PE<sub>1</sub> ... PE<sub>n</sub>) INV(PE))</span> with n > 1, or</li>

  <li><span class="name">ObjectPropertyTransitive(PE)</span>, or</li>

  <li><span class="name">ObjectPropertyTransitive(INV(PE))</span>.</li>

</ul>

<p>The <i>object property hierarchy relation</i> &rarr; is the smallest relation on object property expressions
for which the following conditions hold (<span class="name">A</span> &rarr; <span class="name">B</span> means
that &rarr; holds for <span class="name">A</span> and <span class="name">B</span>):</p>

<ul>

  <li>if <span class="name">Ax</span> contains an axiom
  <span class="name">SubObjectPropertyOf(PE<sub>1</sub> PE<sub>2</sub>)</span>, then
  <span class="name">PE<sub>1</sub></span> &rarr; <span class="name">PE<sub>2</sub></span> holds; and</li>

  <li>if <span class="name">Ax</span> contains an axiom <span class="name">EquivalentObjectProperties(PE<sub>1</sub> PE<sub>2</sub>)</span>, then
  <span class="name">PE<sub>1</sub></span> &rarr; <span class="name">PE<sub>2</sub></span> and
  <span class="name">PE<sub>2</sub></span> &rarr; <span class="name">PE<sub>1</sub></span> hold; and</li>

  <li>if <span class="name">Ax</span> contains an axiom <span class="name">InverseObjectProperties(PE<sub>1</sub> PE<sub>2</sub>)</span>, then
  <span class="name">PE<sub>1</sub></span> &rarr; <span class="name">INV(PE<sub>2</sub>)</span> and
  <span class="name">INV(PE<sub>2</sub>)</span> &rarr; <span class="name">PE<sub>1</sub></span> hold; and</li>

  <li>if <span class="name">Ax</span> contains an axiom <span class="name">SymmetriceObjectProperty(PE)</span>, then
  <span class="name">PE</span> &rarr; <span class="name">INV(PE)</span> holds; and</li>

  <li>if <span class="name">PE<sub>1</sub></span> &rarr; <span class="name">PE<sub>2</sub></span> holds, then
  <span class="name">INV(PE<sub>1</sub>)</span> &rarr; <span class="name">INV(PE<sub>2</sub>)</span> holds as well.

</ul>

<p>The relation &rarr;<sup>*</sup> is the reflexive-transitive closure of &rarr;.
An object property expression <span class="name">PE</span> is <i>simple</i> in <span class="name">Ax</span> if,
for each object property expression <span class="name">PE'</span> such that
<span class="name">PE'</span> &rarr;<sup>*</sup> <span class="name">PE</span> holds,
<span class="name">PE'</span> is not composite.</p>

<p>The axioms <span class="name">Ax</span> satisfy the <i>nonstructural restrictions</i> of OWL 1.1 if the
following two conditions hold:</p>

<ul>

  <li>Only simple object properties are allowed to occur in <span class="name">Ax</span> in

  <ul>

    <li><span class="name">ObjectMinCardinality</span>, <span class="name">ObjectMaxCardinality</span>,
    <span class="name">ObjectExactCardinality</span>, and <span class="name">ObjectExistsSelf</span> classes, and</li>

    <li><span class="name">ObjectPropertyFunctional</span>, <span class="name">InverseFunctionalObjectProperty</span>,
    <span class="name">ObjectPropertyIrreflexive</span>, <span class="name">ObjectPropertyAsymetric</span>,
    and <span class="name">DisjointObjectProperty</span> axioms.</li>

  </ul></li>


  <li>A strict partial order <span class="name">&lt;</span> on the object property expressions must exist
  such that each <span class="name">SubObjectPropertyOf(SUB PE)</span> axiom in <span class="name">Ax</span>
  fulfils the following conditions:

  <ul>

    <li><span class="name">SUB</span> is of the form <span class="name">SubObjectPropertyChain(PE PE)</span>, or</li>

    <li><span class="name">SUB</span> is of the form <span class="name">InverseObjectProperty(PE)</span>, or</li>

    <li><span class="name">SUB</span> is of the form
    <span class="name">SubObjectPropertyChain(PE<sub>1</sub> ... PE<sub>n</sub>)</span> and
    <span class="name">PE<sub>i</sub> &lt; PE</span> for each 1 &le; i &le; n, or</li>

    <li><span class="name">SUB</span> is of the form
    <span class="name">SubObjectPropertyChain(PE PE<sub>1</sub> ... PE<sub>n</sub>)</span> and
    <span class="name">PE<sub>i</sub> &lt; PE</span> for each 1 &le; i &le; n, or</li>

    <li><span class="name">SUB</span> is of the form
    <span class="name">SubObjectPropertyChain(PE<sub>1</sub> ... PE<sub>n</sub> PE)</span> and
    <span class="name">PE<sub>i</sub> &lt; PE</span> for each 1 &le; i &le; n.

  </ul></li>

</ul>



<h2><a name="8"></a>8 Declarations and Structural Consistency</h2>

<p>In addition to axioms, OWL 1.1 also provides <i>declarations</i>, which can be
used to check the <i>structural consistency</i> of an ontology.</p>

<p>In OWL 1.1, it is possible to use a URI for an entity without explicitly
stating that an entity with such a name exists. For example,
the following is a correct OWL 1.1 ontology:</p>

<p class="grammar">
  Ontology(&lt;http://www.my.domain.com/example&gt;<br>
  &nbsp; SubClassOf( Human Animal )<br>
  )
</p>

<p>In this example, the classes <span class="name">Human</span> and <span class="name">Animal</span>
are used without explicitly stating
that they exist. This is desirable in many situations, since it allows
"anyone to say anything about anything," which is consistent with the
vision of the Semantic Web. This approach can, however, make it difficult to detect structural errors in ontologies;
a typographical error in a class name, for example, simply introduces a new class with a different name.</p>

<p>This issue can be addressed by using declarations to check the structural integrity of an ontology.
We say that an entity is declared in an ontology <span class="name">O</span>
if either <span class="name">O</span> or some ontology <span class="name">O'</span>
imported by <span class="name">O</span> contains a declaration axiom for the entity.
Note that an ontology may contain multiple declarations for the same entity, and that imported ontologies may do so as well. An ontology
<span class="name">O</span> is <i>structurally consistent</i>
if each entity occurring in an axiom from the axiom closure of <span class="name">O</span> is
declared in <span class="name">O</span>. Note that, by this definition, the check applies also the entities
used in annotations; that is, these entities must be properly declared as well for an ontology to be structurally consistent.</p>

<p>Note that, although structurally consistency can be a very useful feature in some applications, OWL 1.1 <i>does not require</i>
ontologies to be structurally consistent. Thus, an ontology can be used even if it does not contain any declarations.</p>

<p>As shown in Figure 19, a declaration is a kind of axiom; this is in order to allow an ontology to be treated as simply a set axioms.
A declaration, however, imposes no constraints on the model-theoretic interpretation of an ontology (in the sense
of [<cite><a href="#ref-owl-1.1-semantics">OWL 1.1 Semantics</a></cite>]).</p>

<p class="image"><img src="images/spec/a_declaration.gif" border="0" alt="Entity Declarations in OWL 1.1"><br>
<span class="caption">Figure 19.</span> Entity Declarations in OWL 1.1</p>

<p>The grammar for declaraions is as follows:</p>

<p class="grammar">
  <span class="nonterminal">declaration</span> := 'Declaration' '(' { <span class="nonterminal">annotation</span> } <span class="nonterminal">entity</span> ')'
</p>

<p>Note that the production for the <span class="nonterminal">declaration</span>
nonterminal requires an <span class="nonterminal">entity</span> and
not a URI. Thus, an OWL class should be declared as follows:</p>

<p class="grammar">
  Declaration(OWLClass(Person))
</p>

<p>This is so that the type of the entity being declared can easily be determined from the syntactic form
of the declaration.</p>



<h2><a name="A"></a>Appendix A. Differences from OWL 1.0 Abstract Syntax</h2>

<p>OWL 1.1 departs in its conceptual design and in syntax from
OWL 1.0 Abstract Syntax. In this section we summarize the differences
and explain the rationale behind the changes.</p>

<h3><a name="A.1"></a>A.1 Dropping the Frame-Like Syntax</h3>

<p>OWL 1.0 provides a frame-like syntax that allows several aspects of
a class, property or individual to be defined in a single axiom. For example, one can write the following axiom in OWL 1.0:</p>

<p class="grammar">
  ObjectProperty(partOf inverseOf(containedIn) inverseFunctional transitive<br>
  &nbsp;&nbsp;&nbsp; Label("Specifies that an object is a part of another object.")<br>
  )
</p>

<p>This type of axiom may cause problems in practice. In the first place, 
it bundles many different features of the given object
into a single axiom. While this may be convenient when 
ontologies are being manipulated by hand, it is not convenient for manipulating them programmatically.
In fact, most implementations of OWL 1.0 break such axioms apart into several "atomic"
axioms, each dealing with only a single feature of the object. However, this may cause
problems with round-tripping, as the structure of the ontology may be destroyed in the
process.</p>

<p>In the second place, this type of axiom is often misinterpreted as a declaration and unique
"definition" of the given object. In OWL 1.0, however, objects may be used without being the
subject of any such axiom, and there may be many such axioms relating to the same object.</p>

<p>Finally, OWL 1.0 does not provide means to annotate axioms, which has proved to be quite useful in practice.</p>

<p>These problems are addressed in OWL 1.1 in several ways.
First, the frame-like notation has been dropped in favor of a more
fine-grained structure of axioms, where each axiom describes just one feature of the given
object. Second, OWL 1.1 provides explicit declarations, and
an explicit definition of the notion of structural consistency. Finally, all axioms in OWL 1.1 can be
annotated, and declarations provide means for annotating entities.</p>

<p>For example, the above mentioned OWL 1.0 axiom can be represented in OWL 1.1 as follows:</p>

<p class="grammar">
  Declaration(ObjectProperty(partOf)<br>
  &nbsp;&nbsp;&nbsp; Label("Specifies that an object is a part of another object.")<br>
  )<br>
  EquivalentObjectProperties(partOf InverseObjectProperty(containedIn))<br>
  InverseFunctionalObjectProperty(partOf)<br>
  ObjectPropertyTransitive(Comment("The partOf property is transitive.") partOf)
</p>

<p>Although OWL 1.1 is more verbose, this should not
be a problem given that most OWL ontologies are created
using ontology engineering tools. Moreover, such tools are free to present the
information to the user in a more intuitive (possibly frame-like) way.</p>

<h3><a name="A.2"></a>A.2 Inverse Property Expressions</h3>

<p>In OWL 1.0, all properties are atomic, but it is possible to assert 
that one object property is the inverse of another. For example, one 
can assert the following axiom in OWL 1.0:</p>

<p class="grammar">
  ObjectProperty(hasPart inverse isPartOf)
</p>

<p>In OWL 1.1, property expressions such as <span class="name">InverseObjectProperty(hasPart)</span>
can be used in class expressions, which avoids the need to give a name
to every inverse property. If desired, however, names can still be
given to inverse properties. For example, the following OWL 1.1 axiom
asserts that <span class="name">isPartOf</span> is the inverse of <span class="name">hasPart</span>,
and is thus equivalent to the mentioned OWL 1.0 axiom:</p>

<p class="grammar">
  EquivalentObjectProperties(InverseObjectProperty(hasPart) isPartOf)
</p>

<h3><a name="A.3"></a>A.3 Separating the Vocabulary for Names</h3>

<p>OWL 1.0 relies on the
separation of names between concepts, individuals, and object and
data properties, but the type of a given name may not be obvious from the context in which it is used. Consider, for example, the following OWL 1.0 axiom:</p>

<p class="grammar">
  SubClassOf(Lion restriction(eats someValuesFrom(Animal)))
</p>

<p>From this axiom alone, it is not clear how to
interpret the class <span class="name">restriction(eats someValuesFrom Animal)</span>:
one possibility is to treat <span class="name">eats</span> as an object property
and <span class="name">Animal</span> as a class, and the other one is
to treat <span class="name">eats</span> as a data property and
<span class="name">Animal</span> as a datatype. Examining other axioms in the ontology
(or in an imported ontology) may make it possible to disambiguate this one, but this is not required in OWL 1.0:
an ontology containing only the mentioned axiom is a correct OWL 1.0
ontology in which the intended usage of <span class="name">eats</span> and
<span  class="name">Animal</span> cannot be disambiguated.
Hence,
parsing an OWL 1.0 ontology requires not only two passes through the ontology
being parsed, but also possibly parsing imported ontologies as well;
this makes parser implementation complex and error prone.</p>

<p>This problem is addressed in OWL 1.1 by explicitly typing each usage
of a name. For example, the above mentioned axiom can be represented in OWL 1.1 as follows:</p>

<p class="grammar">
  SubClassOf(Lion ObjectSomeValuesFrom(eats Animal))
</p>

<p>This makes it completely clear that <span class="name">eats</span>
is intended to be interpreted as an object property and
<span class="name">Animal</span> as a class.</p>

<hr>


<h2><a name="references"></a>References</h2>

<dl>

  <dt><a id="ref-owl-1.1-semantics">[OWL 1.1 Semantics]</a></dt>
  <dd>
    <cite><a href="semantics.html">OWL 1.1 Web Ontology Language: Model-Theoretic Semantics</a></cite>.
    Bernardo Cuenca Grau and Boris Motik, eds., 2006.
  </dd>

  <dt><a id="ref-sroiq">[SROIQ]</a></dt>
  <dd>
    <cite><a href="http://www.cs.man.ac.uk/%7Esattler/publications/sroiq-tr.pdf">The Even More Irresistible SROIQ</a></cite>.
    Ian Horrocks, Oliver Kutz, and Uli Sattler.
    In Proc. of the 10th Int. Conf. on Principles of Knowledge Representation and Reasoning (KR 2006). AAAI Press, 2006.
  </dd>

  <dt><a id="ref-xml-namespaces">[XML Namespaces]</a></dt>
  <dd>
    <cite><a href="http://www.w3.org/TR/REC-xml-names/">Namespaces in XML 1.0 (Second Edition)</a></cite>.
    Tim Bray, Dave Hollander, Andrew Layman, and Richard Tobin, eds.
    W3C Recommendation 16 August 2006.
  </dd>

  <dt><a id="ref-xml-schema-datatypes">[XML Schema Datatypes]</a></dt>
  <dd>
    <cite><a href="http://www.w3.org/TR/xmlschema-2/">XML Schema Part 2: Datatypes Second Edition</a></cite>.
    Paul V. Biron and Ashok Malhotra, eds.
    W3C Recommendation 28 October 2004.
  </dd>

  <dt><a id="ref-rdf-syntax">[RDF Syntax]</a></dt>
  <dd>
    <cite><a href="http://www.w3.org/TR/rdf-syntax-grammar/">RDF/XML Syntax Specification (Revised)</a></cite>.
    Dave Beckett, Editor, W3C Recommendation, 10 February 2004, http://www.w3.org/TR/rdf-syntax-grammar/.
  </dd>

  <dt><a id="ref-rfc-3066">[RFC-3066]</a></dt>
  <dd>
    <cite><a href="http://www.ietf.org/rfc/rfc3066.txt">RFC 3066 - Tags for the Identification of Languages</a></cite>.
    H. Alvestrand. IETF, January 2004, http://www.ietf.org/rfc/rfc3066.txt.
  </dd>

  <dt><a id="ref-rfc-3987">[RFC-3987]</a></dt>
  <dd>
    <cite><a href="http://www.ietf.org/rfc/rfc3987.txt">RFC 3066 - Tags for the Identification of Languages</a></cite>.
    M. Duerst, M. Suignard. IETF, January 2005, http://www.ietf.org/rfc/rfc3987.txt.
  </dd>

</dl>

</body>
</html>
