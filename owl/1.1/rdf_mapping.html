<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <title>OWL 1.1 Web Ontology Language: Mapping to RDF Graphs</title>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <link href="css/owl.css" type="text/css" rel="stylesheet">
  <link rel="stylesheet" type="text/css" href="http://www.w3.org/StyleSheets/TR/W3C-Member-SUBM">
  <link href="images/owl-icon.png" rel="shortcut icon">
</head>
<body>

<div class="head">
<h1 class="mainTitle"><img style="float: right; height: 200px;" alt="owl" src="images/owl.png">OWL 1.1 Web Ontology Language<br>
Mapping to RDF Graphs</h1>
<h2><a id="editordraft" name="editordraft"></a>Editor's Draft of 23 May 2007</h2>
<dl>
  <dt>This version:</dt>
  <dd><a href="http://www.webont.com/owl/1.1/rdf_mapping.html">http://www.webont.com/owl/1.1/rdf_mapping.html</a></dd>
  <dt>Latest version:</dt>
  <dd><a href="http://www.webont.com/owl/1.1/rdf_mapping.html">http://www.webont.com/owl/1.1/rdf_mapping.html</a></dd>
  <dt>Authors:</dt>
  <dd><a href="http://www.cs.man.ac.uk/~bcg/">Bernardo Cuenca Grau</a>, The University of Manchester</dd>
  <dd><a href="http://www.cs.man.ac.uk/~bmotik/">Boris Motik</a>, The University of Manchester</dd>
  <dt>Contributors:</dt>
  <dd><a href="http://www.cs.man.ac.uk/~horrocks/">Ian Horrocks</a>, The University of Manchester</dd>
  <dd><a href="http://www.cs.man.ac.uk/~bparsia/">Bijan Parsia</a>, The University of Manchester</dd>
</dl>
<p class="copyright">Copyright &copy; 2006-2007 by the Authors. 
This document is available under the
<a href="http://www.w3.org/Consortium/Legal/copyright-documents" shape="rect">W3C Document License</a>.
See the <a href="http://www.w3.org/Consortium/Legal/ipr-notice#Copyright" shape="rect">W3C Intellectual Rights Notice and Legal Disclaimers</a>
for additional information.</p>
</div>
<hr>

<div class="abstract">
<h2 class="notoc"><a id="abstract" name="abstract">Abstract</a></h2>
<p>OWL 1.1 extends the W3C OWL Web Ontology Language with a small but useful set of features that have been requested by users, for which effective reasoning algorithms are now available, and that OWL tool developers are willing to support. The new features include extra syntactic sugar, additional property and qualified cardinality constructors, extended datatype support, simple metamodelling, and extended annotations. This document provides a mapping from the functional-style syntax of OWL 1.1
to the RDF exchange syntax for OWL 1.1,
and vice versa.</p>
</div>

<div class="status">
<h2 class="notoc"><a id="status" name="status">Status of this Document</a></h2>
<p><strong>This is an editor's draft, for comment by the OWL community.</strong></p>
<p>This document is an evolution of the 
<a href="http://www.w3.org/Submission/2006/SUBM-owl11-rdf_mapping-20061219/">OWL 1.1 Web Ontology Language: Mapping to RDF Graphs</a> document that forms part of the 
<a href="http://www.w3.org/Submission/2006/10/">OWL 1.1 Web Ontology Language W3C Member Submission</a>.
Comments are welcome. Please send feedback to <a href="mailto:public-owl-dev@w3.org">public-owl-dev@w3.org</a>,
which has a <a href="http://lists.w3.org/Archives/Public/public-owl-dev/">public archive</a>. Bug reports
can be directed there. Please check the <a href="http://code.google.com/p/owl1-1/issues/list">issues list</a>
first.</p>
</div>
<hr>

<div class="toc">
<h2 class="notoc"><a id="toc" name="toc">Table of Contents</a></h2>
<ul class="toc">
  <li class="tocline1">1 <a class="tocxref" href="#1">Introduction</a></li>
  <li class="tocline1">2 <a class="tocxref" href="#2">Translation from Functional-Style Syntax to RDF Graphs</a></li>
  <li class="tocline1">3 <a class="tocxref" href="#3"> Translation from RDF Graphs to Functional-Style Syntax</a></li>
  <li class="tocline1"><a class="tocxref" href="#3">References</a></li>
</ul>
</div>

<hr>

<h2>1 <a name="1">Introduction</a></h2>

<p>This document provides a mapping from the functional-style syntax of OWL 1.1 as given in
[<cite><a href="#ref-owl-1.1-specification">OWL 1.1 Specification</a></cite>] to the RDF
exchange syntax for OWL 1.1 and vice versa. Every OWL 1.1 ontology can be serialized in RDF,
so every OWL 1.1 ontology in RDF is a valid OWL Full ontology. The RDF syntax of
OWL 1.1 is backwards-compatible with OWL DL, this is, every OWL DL
ontology in RDF is a valid OWL 1.1 ontology.
The semantics OWL 1.1 is defined for ontologies in the functional-style syntax.
OWL 1.1 ontologies serialized in RDF/XML are interpreted by translating them 
into the functional-style syntax and applying the OWL 1.1 semantics
[<cite><a href="#ref-owl-1.1-semantics">OWL 1.1 Semantics</a></cite>].
The syntax for triples used here is the one used in the RDF Semantics document.
Full URIs are abbreviated using namespaces as usual.</p>

<p>The following notation is used throughout this document:</p>

<ul>
  <li><span class="name">_:x</span> denotes a blank node;</li>

  <li><span class="name">x</span> denotes a blank or a named node;</li>

  <li><span class="name">!x</span> denotes a named node; and</li>

  <li><span class="name">T(SEQ y<sub>1</sub> ... y<sub>n</sub>)</span> denotes the encoding
  of an RDF list as shown in Table 1.</li>
</ul>

<div style="text-align: center">
<table border="2" cellpadding="5">
<caption><span class="caption">Table 1.</span> Transformation of Sequences to Triples</caption>
<tr>
  <th>Sequence S</th>
  <th>Transformation T(S)</th>
  <th>Main Node of T(S)</th>
</tr>
<tr>
  <td class="name">SEQ</td>
  <td>&nbsp;</td>
  <td>rdf:nil</td>
</tr>
<tr>
  <td class="name">SEQ y<sub>1</sub> ... y<sub>n</sub></td>
  <td>
    _:x rdf:type rdf:List<br>
    _:x rdf:first T(y<sub>1</sub>)<br>
    _:x rdf:rest T(SEQ y<sub>2</sub> ... y<sub>n</sub>)<br>
  </td>
  <td>_:x</td>
</tr>
</table>
</div>


<h2>2 <a name="2">Translation from Functional-Style Syntax to RDF Graphs</a></h2>

<p>As explained in [<cite><a href="#ref-owl-1.1-specification">OWL 1.1 Specification</a></cite>],
OWL 1.1 syntax is fully typed -- that is, from the syntax, one can immediately see
what is the intendend usage of some symbol. OWL 1.0 syntax is not typed; rather,
OWL 1.0 relies on explicit statements that determine the type of each URI.
For backwards compatibility, OWL 1.1 uses OWL 1.0 vocabulary whenever there is no
ambiguity. This is made precise using the following definition.</p>

<p>The type of a symbol <span class="name">S</span> in an ontology <span class="name">O</span> (in functional-style syntax),
written <span class="name">Type(S,O)</span>, is defined as the smallest set such that</p>

<ul>
  <li>if the parse tree of <span class="name">O</span> contains <span class="name">S</span> under a
  <span class="nonterminal">objectPropertyURI</span> node, then <i>owl:ObjectProperty</i> &isin; <span class="name">Type(S,O)</span>;</li>

  <li>if the parse tree of <span class="name">O</span> contains <span class="name">S</span> under a
  <span class="nonterminal">dataPropertyURI</span> node, then <i>owl:DatatypeProperty</i> &isin; <span class="name">Type(S,O)</span>;</li>

  <li>if the parse tree of <span class="name">O</span> contains <span class="name">S</span> under a
  <span class="nonterminal">annotationURI</span> node, then <i>owl:AnnotationProperty</i> &isin; <span class="name">Type(S,O)</span>;</li>

  <li>if the parse tree of <span class="name">O</span> contains <span class="name">S</span> under a
  <span class="nonterminal">owlClassURI</span> node, then <i>owl:Class</i> &isin; <span class="name">Type(S,O)</span>;</li>

  <li>if the parse tree of <span class="name">O</span> contains <span class="name">S</span> under a
  <span class="nonterminal">datatypeURI</span> node, then <i>owl:Datatype</i> &isin; <span class="name">Type(S,O)</span>; and</li>

  <li>if the parse tree of <span class="name">O</span> contains <span class="name">S</span> under a
  <span class="nonterminal">individualURI</span> node, then <i>owl11:Individual</i> &isin; <span class="name">Type(S,O)</span>.</li>
</ul>

<p>The above definition refers to a parse tree only for the axioms from <span class="name">O</span>, and not from the
axioms from some ontology that <span class="name">O</span> imports. A symbol <span class="name">S</span> in <i>punned</i> in an
ontology <span class="name">O</span> if <span class="name">Type(S,O)</span> contains more than one element.
Based on that, the following two conditions are defined:</p>

<ul>
  <li><span class="name">OnlyOP(S)</span> is <span class="name">true</span> if and only if <i>owl:ObjectProperty</i> &isin; <span class="name">Type(S,O)</span>
  and <i>owl:DatatypeProperty</i> and <i>owl:AnnotationProperty</i> are not in <span class="name">Type(S,O)</span>;</li>

  <li><span class="name">OnlyDP(S)</span> is <span class="name">true</span> if and only if <i>owl:DatatypeProperty</i> &isin; <span class="name">Type(S,O)</span>
  and <i>owl:ObjectProperty</i> and <i>owl:AnnotationProperty</i> are not in <span class="name">Type(S,O)</span>;</li>

  <li><span class="name">OnlyAP(S)</span> is <span class="name">true</span> if and only if <i>owl:AnnotationProperty</i> &isin; <span class="name">Type(S,O)</span>
  and <i>owl:ObjectProperty</i> and <i>owl:DatatypeProperty</i> are not in <span class="name">Type(S,O)</span>.</li>
</ul>


<p>The following shortcuts are used in the translation of OWL 1.1 ontologies into RDF:</p>

<ul>
  <li><span class="name">RESTRICTION[op]</span> expands to <i>owl:Restriction</i> if
  <span class="name">OnlyOP(op) = true</span>, and to <i>owl11:ObjectRestriction</i> otherwise;</li>

  <li><span class="name">RESTRICTION[dp]</span> expands to <i>owl:Restriction</i> if
  <span class="name">OnlyDP(dp) = true</span>, and to <i>owl11:DataRestriction</i> otherwise;</li>

  <li><span class="name">SUBPROPERTYOF[op<sub>1</sub>,...,op<sub>n</sub>]</span> expands to <i>rdfs:subPropertyOf</i> if
  <span class="name">OnlyOP(op<sub>i</sub>) = true</span> for each 1 &#8804; i &#8804; n, and to <i>owl11:subObjectPropertyOf</i> otherwise;</li>

  <li><span class="name">SUBPROPERTYOF[dp<sub>1</sub>,dp<sub>2</sub>]</span> expands to <i>rdfs:subPropertyOf</i> if
  <span class="name">OnlyDP(dp<sub>1</sub>) = true</span> and <span class="name">OnlyDP(dp<sub>2</sub>) = true</span>,
  and to <i>owl11:subDataPropertyOf</i> otherwise;</li>

  <li><span class="name">EQUIVALENTPROPERTY[op<sub>1</sub>,...,op<sub>n</sub>]</span> expands to <i>owl:equivalentProperty</i> if
  <span class="name">OnlyOP(op<sub>i</sub>) = true</span> for each 1 &#8804; i &#8804; n, and to <i>owl11:equivalentObjectProperty</i> otherwise;</li>

  <li><span class="name">EQUIVALENTPROPERTY[dp<sub>1</sub>,...,dp<sub>n</sub>]</span> expands to <i>owl:equivalentProperty</i> if
  <span class="name">OnlyDP(dp<sub>i</sub>) = true</span> for each 1 &#8804; i &#8804; n, and to <i>owl11:equivalentDataProperty</i> otherwise;</li>

  <li><span class="name">FUNCTIONALPROPERTY[op]</span> expands to <i>owl:FunctionalProperty</i> if
  <span class="name">OnlyOP(op) = true</span>, and to <i>owl11:FunctionalObjectProperty</i> otherwise;</li>

  <li><span class="name">FUNCTIONALPROPERTY[dp]</span> expands to <i>owl:FunctionalProperty</i> if
  <span class="name">OnlyDP(dp) = true</span>, and to <i>owl11:FunctionalDataProperty</i> otherwise;</li>

  <li><span class="name">DOMAIN[op]</span> expands to <i>rdfs:domain</i> if
  <span class="name">OnlyOP(op) = true</span>, and to <i>owl11:objectPropertyDomain</i> otherwise;</li>

  <li><span class="name">DOMAIN[dp]</span> expands to <i>rdfs:domain</i> if
  <span class="name">OnlyDP(dp) = true</span>, and to <i>owl11:dataPropertyDomain</i> otherwise;</li>

  <li><span class="name">RANGE[op]</span> expands to <i>rdfs:range</i> if
  <span class="name">OnlyOP(op) = true</span>, and to <i>owl11:objectPropertyRange</i> otherwise; and</li>

  <li><span class="name">RANGE[dp]</span> expands to <i>rdfs:range</i> if
  <span class="name">OnlyDP(dp) = true</span>, and to <i>owl11:dataPropertyRange</i> otherwise.</li>
</ul>

<p>Table 2 presents the operator <span class="name">T</span> that translates an OWL 1.1 ontology
in functional-style syntax into a set of RDF triples. This table does not consider axioms with annotations.</p>

<div style="text-align: center">
<table border="2" cellpadding="5">
<caption><span class="caption">Table 2.</span> <a id="transformation">Transformation to Triples</a></caption>
<tr>
  <th>Functional-Style Syntax S</th>
  <th>Transformation T(S)</th>
  <th>Main Node of T(S)</th>
</tr>
<tr>
  <td class="name">
    Ontology(ontologyURI<br>
    &nbsp;&nbsp;Import(oID<sub>1</sub>) ... Import(oID<sub>k</sub>)<br>
    &nbsp;&nbsp;Annotation(apID<sub>1</sub> ct<sub>1</sub>) ... Annotation(apID<sub>n</sub> ct<sub>n</sub>)<br>
    &nbsp;&nbsp;axiom<sub>1</sub> ... axiom<sub>m</sub>)
   </td>
  <td>
    ontologyURI rdf:type owl:Ontology<br>
    ontologyURI owl:imports oID<sub>i</sub> &nbsp; 1 &#8804; i &#8804; k<br>
    ontologyURI T(apID<sub>i</sub>) T(ct<sub>i</sub>) &nbsp; 1 &#8804; i &#8804; n<br>
    T(axiom<sub>i</sub>) &nbsp; 1 &#8804; i &#8804; m
  </td>
  <td>ontologyURI</td>
</tr>
<tr>
  <td class="name"><span class="syntax">datatypeURI</span></td>
  <td>datatypeURI rdf:type rdfs:Datatype</td>
  <td>datatypeURI</td>
</tr>
<tr>
  <td class="name">owlClassURI</td>
  <td>owlClassURI rdf:type owl:Class</td>
  <td>owlClassURI</td>
</tr>
<tr>
  <td class="name">objectPropertyURI</td>
  <td>objectPropertyURI rdf:type owl:ObjectProperty</td>
  <td>objectPropertyURI</td>
</tr>
<tr>
  <td class="name">dataPropertyURI</td>
  <td>dataPropertyURI rdf:type owl:DatatypeProperty</td>
  <td>dataPropertyURI</td>
</tr>
<tr>
  <td class="name">annotationURI</td>
  <td>annotationURI rdf:type owl:AnnotationProperty</td>
  <td>annotationURI</td>
</tr>
<tr>
  <td class="name">individualURI</td>
  <td>&nbsp;</td>
  <td>individualURI</td>
</tr>
<tr>
  <td class="name">constant</td>
  <td>&nbsp;</td>
  <td>constant</td>
</tr>
<tr>
  <td class="name">DataComplementOf(dr)</td>
  <td>
    _:x rdf:type owl:DataRange<br>
    _:x owl:complementOf T(dr)
  </td>
  <td>_:x</td>
</tr>
<tr>
  <td class="name">DataOneOf(ct<sub>1</sub> ... ct<sub>n</sub>)</td>
  <td>
    _:x rdf:type owl:DataRange<br>
    _:x owl:oneOf T(SEQ ct<sub>1</sub> ... ct<sub>n</sub>)
  </td>
  <td>_:x</td>
</tr>
<tr>
  <td class="name">DatatypeRestriction(dr facet ct)</td>
  <td>
    _:x rdf:type owl:DataRange<br>
    _:x owl11:onDataRange T(dr)<br>
    _:x owl11:<i>facet</i> ct
  </td>
  <td>_:x</td>
</tr>
<tr>
  <td class="name">InverseObjectProperty(op)</td>
  <td>:_x owl11:inverseObjectPropertyExpression T(op)</td>
  <td>_:x</td>
</tr>
<tr>
  <td class="name">ObjectUnionOf(c<sub>1</sub> ... c<sub>n</sub>)</td>
  <td>
    _:x rdf:type owl:Class<br>
    _:x owl:unionOf T(SEQ c<sub>1</sub> ... c<sub>n</sub>)
  </td>
  <td>_:x</td>
</tr>
<tr>
  <td class="name">ObjectIntersectionOf(c<sub>1</sub> ... c<sub>n</sub>)</td>
  <td>
    _:x rdf:type owl:Class<br>
    _:x owl:intersectionOf T(SEQ c<sub>1</sub> ... c<sub>n</sub>)
  </td>
  <td>_:x</td>
</tr>
<tr>
  <td class="name">ObjectComplementOf(c)</td>
  <td>
    _:x rdf:type owl:Class<br>
    _:x owl:complementOf T(c)
  </td>
  <td>_:x</td>
</tr>
<tr>
  <td class="name">ObjectOneOf(iID<sub>1</sub> ... iID<sub>n</sub>)</td>
  <td>
    _:x rdf:type owl:Class<br>
    _:x owl:oneOf T(SEQ iID<sub>1</sub> ... iID<sub>n</sub>)
  </td>
  <td>_:x</td>
</tr>
<tr>
  <td class="name">ObjectSomeValuesFrom(op c)</td>
  <td>
    _:x rdf:type RESTRICTION[op]<br>
    _:x owl:onProperty T(op)<br>
    _:x owl:someValuesFrom T(c)
  </td>
  <td>_:x</td>
</tr>
<tr>
  <td class="name">ObjectAllValuesFrom(op c)</td>
  <td>
    _:x rdf:type RESTRICTION[op]<br>
    _:x owl:onProperty T(op)<br>
    _:x owl:allValuesFrom T(c)
  </td>
  <td>_:x</td>
</tr>
<tr>
  <td class="name">ObjectExistsSelf(op)</td>
  <td>
    _:x rdf:type owl11:SelfRestriction<br>
    _:x owl:onProperty T(op)<br>
  </td>
  <td>_:x</td>
</tr>
<tr>
  <td class="name">ObjectHasValue(op iID)</td>
  <td>
    _:x rdf:type RESTRICTION[op]<br>
    _:x owl:onProperty T(op)<br>
    _:x owl:hasValue T(iID)
  </td>
  <td>_:x</td>
</tr>
<tr>
  <td class="name">ObjectMinCardinality(n op c)</td>
  <td>
    _:x rdf:type RESTRICTION[op]<br>
    _:x owl:minCardinality "n"^^xsd:nonNegativeInteger<br>
    _:x owl:onProperty T(op)<br>
    _:x owl11:onClass T(c)
  </td>
  <td>_:x</td>
</tr>
<tr>
  <td class="name">ObjectMaxCardinality(n op c)</td>
  <td>
    _:x rdf:type RESTRICTION[op]<br>
    _:x owl:maxCardinality "n"^^xsd:nonNegativeInteger<br>
    _:x owl:onProperty T(op)<br>
    _:x owl11:onClass T(c)
  </td>
  <td>_:x</td>
</tr>
<tr>
  <td class="name">ObjectExactCardinality(n op c)</td>
  <td>
    _:x rdf:type RESTRICTION[op]<br>
    _:x owl:cardinality "n"^^xsd:nonNegativeInteger<br>
    _:x owl:onProperty T(op)<br>
    _:x owl11:onClass T(c)
  </td>
  <td>_:x</td>
</tr>
<tr>
  <td class="name">ObjectMinCardinality(n op)</td>
  <td>
    _:x rdf:type RESTRICTION[op]<br>
    _:x owl:minCardinality "n"^^xsd:nonNegativeInteger<br>
    _:x owl:onProperty T(op)
  </td>
  <td>_:x</td>
</tr>
<tr>
  <td class="name">ObjectMaxCardinality(n op)</td>
  <td>
    _:x rdf:type RESTRICTION[op]<br>
    _:x owl:maxCardinality "n"^^xsd:nonNegativeInteger<br>
    _:x owl:onProperty T(op)
  </td>
  <td>_:x</td>
</tr>
<tr>
  <td class="name">ObjectExactCardinality(n op)</td>
  <td>
    _:x rdf:type RESTRICTION[op]<br>
    _:x owl:cardinality "n"^^xsd:nonNegativeInteger<br>
    _:x owl:onProperty T(op)
  </td>
  <td>_:x</td>
</tr>
<tr>
  <td class="name">DataSomeValuesFrom(dp dr)</td>
  <td>
    _:x rdf:type RESTRICTION[dp]<br>
    _:x owl:onProperty T(dp)<br>
    _:x owl:someValuesFrom T(dr)
  </td>
  <td>_:x</td>
</tr>
<tr>
  <td class="name">DataSomeValuesFrom(dp<sub>1</sub> ... dp<sub>n</sub> dr)</td>
  <td>
    _:x rdf:type RESTRICTION[dp]<br>
    _:x owl:onProperty T(SEQ dp<sub>1</sub> ... dp<sub>n</sub>)<br>
    _:x owl:someValuesFrom T(dr)
  </td>
  <td>_:x</td>
</tr>
<tr>
  <td class="name">DataAllValuesFrom(dp dr)</td>
  <td>
    _:x rdf:type RESTRICTION[dp]<br>
    _:x owl:onProperty T(dp) <br>
    _:x owl:allValuesFrom T(dr)
  </td>
  <td>_:x</td>
</tr>
<tr>
  <td class="name">DataAllValuesFrom(dp<sub>1</sub> ... dp<sub>n</sub> dr)</td>
  <td>
    _:x rdf:type RESTRICTION[dp]<br>
    _:x owl:onProperty T(SEQ dp<sub>1</sub> ... dp<sub>n</sub>)<br>
    _:x owl:allValuesFrom T(dr)
  </td>
  <td>_:x</td>
</tr>
<tr>
  <td class="name">DataHasValue(dp ct)</td>
  <td>
    _:x rdf:type RESTRICTION[dp]<br>
    _:x owl:onProperty T(dp)<br>
    _:x owl:hasValue T(ct)
  </td>
  <td>_:x</td>
</tr>
<tr>
  <td class="name">DataMinCardinality(n dp dr)</td>
  <td>
    _:x rdf:type RESTRICTION[dp]<br>
    _:x owl:minCardinality "n"^^xsd:nonNegativeInteger<br>
    _:x owl:onProperty T(dp)<br>
    _:x owl11:onDataRange T(dr)
  </td>
  <td>_:x</td>
</tr>
<tr>
  <td class="name">DataMaxCardinality(n dp dr)</td>
  <td>
    _:x rdf:type RESTRICTION[dp]<br>
    _:x owl:maxCardinality "n"^^xsd:nonNegativeInteger<br>
    _:x owl:onProperty T(dp)<br>
    _:x owl11:onDataRange T(dr)
  </td>
  <td>_:x</td>
</tr>
<tr>
  <td class="name">DataExactCardinality(n dp dr)</td>
  <td>
    _:x rdf:type RESTRICTION[dp]<br>
    _:x owl:cardinality "n"^^xsd:nonNegativeInteger<br>
    _:x owl:onProperty T(dp)<br>
    _:x owl11:onDataRange T(dr)
  </td>
  <td>_:x</td>
</tr>
<tr>
  <td class="name">DataMinCardinality(n dp)</td>
  <td>
    _:x rdf:type RESTRICTION[dp]<br>
    _:x owl:minCardinality "n"^^xsd:nonNegativeInteger<br>
    _:x owl:onProperty T(dp)
  </td>
  <td>_:x</td>
</tr>
<tr>
  <td class="name">DataMaxCardinality(n dp)</td>
  <td>
    _:x rdf:type RESTRICTION[dp]<br>
    _:x owl:maxCardinality "n"^^xsd:nonNegativeInteger<br>
    _:x owl:onProperty T(dp)
  </td>
  <td>_:x</td>
</tr>
<tr>
  <td class="name">DataExactCardinality(n dp)</td>
  <td>
    _:x rdf:type RESTRICTION[dp]<br>
    _:x owl:cardinality "n"^^xsd:nonNegativeInteger<br>
    _:x owl:onProperty T(dp)
  </td>
  <td>_:x</td>
</tr>
<tr>
  <td class="name">
    EntityAnnotation(Datatype(dID)<br>
    &nbsp;&nbsp;Annotation(apID<sub>1</sub> ct<sub>1</sub>) ... Annotation(apID<sub>n</sub> ct<sub>n</sub>))
  </td>
  <td>
    dID T(apID<sub>i</sub>) T(ct<sub>i</sub>) &nbsp; 1 &#8804; i &#8804; n
  </td>
  <td>&nbsp;</td>
</tr>
<tr>
  <td class="name">
    EntityAnnotation(OWLClass(cID)<br>
    &nbsp;&nbsp;Annotation(apID<sub>1</sub> ct<sub>1</sub>) ... Annotation(apID<sub>n</sub> ct<sub>n</sub>))
  </td>
  <td>
    dID T(apID<sub>i</sub>) T(ct<sub>i</sub>) &nbsp; 1 &#8804; i &#8804; n
  </td>
  <td>&nbsp;</td>
</tr>
<tr>
  <td class="name">
    &nbsp;&nbsp;Annotation(apID<sub>1</sub> ct<sub>1</sub>) ... Annotation(apID<sub>n</sub> ct<sub>n</sub>))
  </td>
  <td>
    opID T(apID<sub>i</sub>) T(ct<sub>i</sub>) &nbsp; 1 &#8804; i &#8804; n
  </td>
  <td>&nbsp;</td>
</tr>
<tr>
  <td class="name">
    EntityAnnotation(DataProperty(dpID)<br>
    &nbsp;&nbsp;Annotation(apID<sub>1</sub> ct<sub>1</sub>) ... Annotation(apID<sub>n</sub> ct<sub>n</sub>))
  </td>
  <td>
    dpID T(apID<sub>i</sub>) T(ct<sub>i</sub>) &nbsp; 1 &#8804; i &#8804; n
  </td>
  <td>&nbsp;</td>
</tr>
<tr>
  <td class="name">
    EntityAnnotation(Individual(iID)<br>
    &nbsp;&nbsp;Annotation(apID<sub>1</sub> ct<sub>1</sub>) ... Annotation(apID<sub>n</sub> ct<sub>n</sub>))
  </td>
  <td>
    dpID T(apID<sub>i</sub>) T(ct<sub>i</sub>) &nbsp; 1 &#8804; i &#8804; n
  </td>
  <td>&nbsp;</td>
</tr>
<tr>
  <td class="name">SubClassOf(c<sub>1</sub> c<sub>2</sub>)</td>
  <td>T(c<sub>1</sub>) rdfs:subClassOf T(c<sub>2</sub>)</td>
  <td>&nbsp;</td>
</tr>
<tr>
  <td class="name">EquivalentClasses(c<sub>1</sub> ... c<sub>n</sub>)</td>
  <td>T(c<sub>i</sub>) owl:equivalentClass T(c<sub>i+1</sub>) &nbsp; 1 &#8804; i &#8804; n-1</td>
  <td>&nbsp;</td>
</tr>
<tr>
  <td class="name">DisjointClasses(c<sub>1</sub> ... c<sub>n</sub>)</td>
  <td>T(c<sub>i</sub>) owl:disjointWith T(c<sub>j</sub>) &nbsp; 1 &#8804; i, j &#8804; n, i &#8800; j</td>
  <td>&nbsp;</td>
</tr>
<tr>
  <td class="name">DisjointUnion(cID c<sub>1</sub> ... c<sub>n</sub>)</td>
  <td>T(cID) owl11:disjointUnionOf T(SEQ c<sub>1</sub> ... c<sub>n</sub>)</td>
  <td>&nbsp;</td>
</tr>
<tr>
  <td class="name">SubObjectPropertyOf(op<sub>1</sub> op<sub>2</sub>)</td>
  <td>T(op<sub>1</sub>) SUBPROPERTYOF[op<sub>1</sub>,op<sub>2</sub>] T(op<sub>2</sub>)</td>
  <td>&nbsp;</td>
</tr>
<tr>
  <td class="name">
    SubObjectPropertyOf(<br>
    &nbsp;&nbsp;subObjectPropertyChain(op<sub>1</sub> ... op<sub>n</sub>) op)
  </td>
  <td>T(SEQ op<sub>1</sub> ... op<sub>n</sub>) SUBPROPERTYOF[op<sub>1</sub>,...,op<sub>n</sub>,op] T(op)</td>
  <td>&nbsp;</td>
</tr>
<tr>
  <td class="name">EquivalentObjectProperties(op<sub>1</sub> ... op<sub>n</sub>)</td>
  <td>T(op<sub>i</sub>) EQUIVALENTPROPERTY[op<sub>1</sub>,...,op<sub>n</sub>] T(op<sub>i+1</sub>) &nbsp; 1 &#8804; i &#8804; n-1</td>
  <td>&nbsp;</td>
</tr>
<tr>
  <td class="name">DisjointObjectProperties(op<sub>1</sub> ... op<sub>n</sub>)</td>
  <td>T(op<sub>i</sub>) owl11:disjointObjectProperties T(op<sub>j</sub>) &nbsp; 1 &#8804; i, j &#8804; n, i &#8800; j</td>
  <td>&nbsp;</td>
</tr>
<tr>
  <td class="name">ObjectPropertyDomain(op c)</td>
  <td>T(op) DOMAIN[op] T(c)</td>
  <td>&nbsp;</td>
</tr>
<tr>
  <td class="name">ObjectPropertyRange(op c)</td>
  <td>T(op) RANGE[op] T(c)</td>
  <td>&nbsp;</td>
</tr>
<tr>
  <td class="name">InverseObjectProperties(op<sub>1</sub> op<sub>2</sub>)</td>
  <td>T(op<sub>1</sub>) owl:inverseOf T(op<sub>2</sub>)</td>
  <td>&nbsp;</td>
</tr>
<tr>
  <td class="name">TransitiveObjectProperty(op)</td>
  <td>T(op) rdf:type owl:TransitiveProperty</td>
  <td>&nbsp;</td>
</tr>
<tr>
  <td class="name">FunctionalObjectProperty(op)</td>
  <td>T(op) rdf:type FUNCTIONALPROPERTY[op]</td>
  <td>&nbsp;</td>
</tr>
<tr>
  <td class="name">InverseFunctionalObjectProperty(op)</td>
  <td>T(op) rdf:type owl:InverseFunctionalProperty</td>
  <td>&nbsp;</td>
</tr>
<tr>
  <td class="name">ReflexiveObjectProperty(op)</td>
  <td>T(op) rdf:type owl11:ReflexiveProperty</td>
  <td>&nbsp;</td>
</tr>
<tr>
  <td class="name">IrreflexiveObjectProperty(op)</td>
  <td>T(op) rdf:type owl11:IrreflexiveProperty</td>
  <td>&nbsp;</td>
</tr>
<tr>
  <td class="name">SymmetricObjectProperty(op)</td>
  <td>T(op) rdf:type owl:SymmetricProperty</td>
  <td>&nbsp;</td>
</tr>
<tr>
  <td class="name">AsymmetricObjectProperty(op)</td>
  <td>T(op) rdf:type owl11:AsymmetricProperty</td>
  <td>&nbsp;</td>
</tr>
<tr>
  <td class="name">SubDataPropertyOf(dp<sub>1</sub> dp<sub>2</sub>)</td>
  <td>T(dp<sub>1</sub>) SUBPROPERTYOF[dp<sub>1</sub>,dp<sub>2</sub>] T(dp<sub>2</sub>)</td>
  <td>&nbsp;</td>
</tr>
<tr>
  <td class="name">EquivalentDataProperties(dp<sub>1</sub> ... dp<sub>n</sub>)</td>
  <td>T(dp<sub>i</sub>) EQUIVALENTPROPERTY[dp<sub>1</sub>,...,dp<sub>n</sub>] T(dp<sub>i+1</sub>) &nbsp; 1 &#8804; i &#8804; n-1</td>
  <td>&nbsp;</td>
</tr>
<tr>
  <td class="name">DisjointDataProperties(dp<sub>1</sub> ... dp<sub>n</sub>)</td>
  <td>T(dp<sub>i</sub>) owl11:disjointDataProperties T(dp<sub>j</sub>) &nbsp; 1 &#8804; i, j &#8804; n, i &#8800; j</td>
  <td>&nbsp;</td>
</tr>
<tr>
  <td class="name">DataPropertyDomain(dp c)</td>
  <td>T(dp) DOMAIN[dp] T(c)</td>
  <td>&nbsp;</td>
</tr>
<tr>
  <td class="name">DataPropertyRange(dp dr)</td>
  <td>T(op) RANGE[dp] T(dr)</td>
  <td>&nbsp;</td>
</tr>
<tr>
  <td class="name">FunctionalDataProperty(dp)</td>
  <td>T(dp) rdf:type FUNCTIONALPROPERTY[dp]</td>
  <td>&nbsp;</td>
</tr>
<tr>
  <td class="name">SameIndividual(iID<sub>1</sub> ... iID<sub>n</sub>)</td>
  <td>T(iID<sub>i</sub>) owl:sameAs T(iID<sub>i+1</sub>) &nbsp; 1 &#8804; i &#8804; n-1</td>
  <td>&nbsp;</td>
</tr>
<tr>
  <td class="name">DifferentIndividuals(iID<sub>1</sub> ... iID<sub>n</sub>)</td>
  <td>T(iID<sub>i</sub>) owl:differentFrom T(iID<sub>j</sub>) &nbsp; 1 &#8804; i, j &#8804; n, i &#8800; j</td>
  <td>&nbsp;</td>
</tr>
<tr>
  <td class="name">ClassAssertion(iID c)</td>
  <td>T(iID) rdf:type T(c)</td>
  <td>&nbsp;</td>
</tr>
<tr>
  <td class="name">ObjectPropertyAssertion(op iID<sub>1</sub> iID<sub>2</sub>)</td>
  <td>T(iID<sub>1</sub>) T(op) T(iID<sub>2</sub>)</td>
  <td>&nbsp;</td>
</tr>
<tr>
  <td class="name">NegativeObjectPropertyAssertion(op iID<sub>1</sub> iID<sub>2</sub>)</td>
  <td>
    _:x rdf:type owl11:NegativeObjectPropertyAssertion<br>
    _:x rdf:subject T(iID<sub>1</sub>)<br>
    _:x rdf:predicate T(op)<br>
    _:x rdf:object T(iID<sub>2</sub>)
  </td>
  <td>&nbsp;</td>
</tr>
<tr>
  <td class="name">DataPropertyAssertion(dp iID ct)</td>
  <td>T(iID) T(dp) T(ct)</td>
  <td>&nbsp;</td>
</tr>
<tr>
  <td class="name">NegativeDataPropertyAssertion(op iID ct)</td>
  <td>
    _:x rdf:type owl11:NegativeDataPropertyAssertion<br>
    _:x rdf:subject T(iID)<br>
    _:x rdf:predicate T(dp)<br>
    _:x rdf:object T(ct)
  </td>
  <td>&nbsp;</td>
</tr>
<tr>
  <td class="name">
    Declaration(Datatype(dID))
  </td>
  <td>
    T(dID) owl11:declaredAs owl:Datatype
  </td>
  <td>&nbsp;</td>
</tr>
<tr>
  <td class="name">
    Declaration(OWLClass(cID))
  </td>
  <td>
    T(cID) owl11:declaredAs owl:Class
  </td>
  <td>&nbsp;</td>
</tr>
<tr>
  <td class="name">
    Declaration(ObjectProperty(opID))
  </td>
  <td>
    T(opID) owl11:declaredAs owl:ObjectProperty
  </td>
  <td>&nbsp;</td>
</tr>
<tr>
  <td class="name">
    Declaration(DataProperty(dpID))
  </td>
  <td>
    T(dpID) owl11:declaredAs owl:DatatypeProperty
  </td>
  <td>&nbsp;</td>
</tr>
<tr>
  <td class="name">
    Declaration(Individual(iID))
  </td>
  <td>
    T(iID) owl11:declaredAs owl11:Individual
  </td>
  <td>&nbsp;</td>
</tr>
</table>
</div>

<p>Axioms with annotations are reified. If <span class="name">s p o</span> is the
RDF serialization of the corresponding axiom without annotations given in Table 2 and the axiom
contains annotations <span class="name">Annotation(apID<sub>i</sub> ct<sub>i</sub>)</span>, 1 &#8804; i &#8804; n,
then, instead of being serialized as <span class="name">s p o</span>, the axiom is serialized as follows:</p>

<p class="grammar">
  _:x rdf:type owl11:Axiom<br>
  _:x T(apID<sub>i</sub>) T(ct<sub>i</sub>) &nbsp; 1 &#8804; i &#8804; n<br>
  _:x rdf:subject s<br>
  _:x rdf:predicate p<br>
  _:x rdf:object o
</p>

<p>Negative object and data property assertions are already reified so only the following triples are
added if an assertion contains an annotation:</p>

<p class="grammar">
  _:x T(apID<sub>i</sub>) T(ct<sub>i</sub>) &nbsp; 1 &#8804; i &#8804; n
</p>
  


<h2>3 <a name="3">Translation from RDF Graphs to Functional-Style Syntax</a></h2>

<p>This section specifies how to translate a set of RDF triples <span class="name">G</span> into an
OWL 1.1 ontology in functional-style syntax <span class="name">O</span>, if possible.
The function <span class="name">Type(x)</span> assigns a set of types to each resource node <span class="name">x</span>
in <span class="name">G</span> (in this and all other definitions, the graph <span class="name">G</span> is
implicitly understood and is not specified explicitly) and is defined as the smallest set satisfying the
conditions from Table 3.</p>


<div style="text-align: center">
<table border="2" cellpadding="5">
<caption><span class="caption">Table 3.</span> Types of Nodes in a Graph</caption>
<tr>
  <th>If <span class="name">G</span> contains a triple of this form...</th>
  <th>...then <span class="name">Type(x)</span> must contain this URI.</th>
</tr>
<tr>
  <td class="name">x rdf:type owl:Class</td>
  <td>owl:Class</td>
</tr>
<tr>
  <td class="name">x rdf:type owl:Restriction</td>
  <td>owl:Class</td>
</tr>
<tr>
  <td class="name">x rdf:type owl11:ObjectRestriction</td>
  <td>owl:Class</td>
</tr>
<tr>
  <td class="name">x rdf:type owl11:DataRestriction</td>
  <td>owl:Class</td>
</tr>
<tr>
  <td class="name">x rdf:type owl:DataRange</td>
  <td>owl:DataRange</td>
</tr>
<tr>
  <td class="name">x rdf:type owl:Datatype</td>
  <td>owl:DataRange</td>
</tr>
<tr>
  <td class="name">x rdf:type owl:ObjectProperty</td>
  <td>owl:ObjectProperty</td>
</tr>
<tr>
  <td class="name">x rdf:type owl:TransitiveProperty</td>
  <td>owl:ObjectProperty</td>
</tr>
<tr>
  <td class="name">x rdf:type owl:SymmetricProperty</td>
  <td>owl:ObjectProperty</td>
</tr>
<tr>
  <td class="name">x rdf:type owl11:AsymmetricProperty</td>
  <td>owl:ObjectProperty</td>
</tr>
<tr>
  <td class="name">x rdf:type owl11:ReflexiveProperty</td>
  <td>owl:ObjectProperty</td>
</tr>
<tr>
  <td class="name">x rdf:type owl11:IrreflexiveProperty</td>
  <td>owl:ObjectProperty</td>
</tr>
<tr>
  <td class="name">x rdf:type owl11:FunctionalObjectProperty</td>
  <td>owl:ObjectProperty</td>
</tr>
<tr>
  <td class="name">x rdf:type owl:DatatypeProperty</td>
  <td>owl:DatatypeProperty</td>
</tr>
<tr>
  <td class="name">x rdf:type owl:FunctionalDataProperty</td>
  <td>owl:DatatypeProperty</td>
</tr>
<tr>
  <td class="name">x rdf:type owl:AnnotationProperty</td>
  <td>owl:AnnotationProperty</td>
</tr>
<tr>
  <td class="name">x rdf:type owl11:Individual</td>
  <td>owl11:Individual</td>
</tr>
</table>
</div>

<p>For a resource node <span class="name">x</span>, the functions <span class="name">OnlyOP(x)</span> and <span class="name">OnlyDP(x)</span>
are defined as follows:</p>

<ul>
  <li><span class="name">OnlyOP(x)</span> is <span class="name">true</span> if and only if <i>owl:ObjectProperty</i> &isin; <span class="name">Type(x)</span>
  and <i>owl:DatatypeProperty</i> and <i>owl:AnnotationProperty</i> are not in <span class="name">Type(x)</span>;</li>

  <li><span class="name">OnlyDP(x)</span> is <span class="name">true</span> if and only if <i>owl:DatatypeProperty</i> &isin; <span class="name">Type(x)</span>
  and <i>owl:ObjectProperty</i> and <i>owl:AnnotationProperty</i> are not in <span class="name">Type(x)</span>;</li>

  <li><span class="name">OnlyAP(x)</span> is <span class="name">true</span> if and only if <i>owl:AnnotationProperty</i> &isin; <span class="name">Type(x)</span>
  and <i>owl:ObjectProperty</i> and <i>owl:DatatypeProperty</i> are not in <span class="name">Type(x)</span>.</li>
</ul>

<p>The following partial functions are defined for each resource node <span class="name">x</span>:</p>

<ul>
  <li><span class="name">OP(x)</span> assigns to <span class="name">x</span> an object property expression;</li>

  <li><span class="name">DP(x)</span> assigns to <span class="name">x</span> a data property expression;</li>

  <li><span class="name">DRANGE(x)</span> assigns to <span class="name">x</span> a data range; and</li>

  <li><span class="name">DESC(x)</span> assigns to <span class="name">x</span> a description.</li>
</ul>

<p>These functions are defined inductively by the following conditions. For the induction to correctly defined,
it should be possible to order all resource nodes in <span class="name">G</span>
such that there are no cyclic dependencies in the second condition; if this is not possible, then
<span class="name">G</span> cannot be converted into an OWL 1.1 ontology.</p>

<ul>
  <li>If <span class="name">x</span> is not a blank node, then set <span class="name">OP(x)</span>, 
  <span class="name">DP(x)</span>, <span class="name">DRANGE(x)</span>, and <span class="name">DESC(x)</span>
  to <span class="name">x</span>.</li>

  <li>For each triple pattern from the first column of Table 4 occurring in <span class="name">G</span>,
  set <span class="name">OP(x)</span> to the object property expression from the second column.</li>

  <li>For each triple pattern from the first column of Table 5 occurring in <span class="name">G</span>,
  set <span class="name">DRANGE(x)</span> to the data range from the second column.</li>

  <li>For each tiple pattern from the first column of Table 6 occurring <span class="name">G</span>,
  set <span class="name">DESC(x)</span> to the description from the second column.</li>

  <li>If there is more than one way of assigning a value to any one of these functions,
  then <span class="name">G</span> cannot be translated into an OWL 1.1 ontology. Also,
  if the value of one of these functions is not defined for some node occurring in
  the functional-style syntax encoding, then <span class="name">G</span> cannot be translated into an OWL 1.1 ontology.</li>
</ul>


<div style="text-align: center">
<table border="2" cellpadding="5">
<caption><span class="caption">Table 4.</span> Translation of Triples to Object Property Expressions</caption>
<tr>
  <th>Pattern</th>
  <th>Object Property Expression</th>
</tr>
<tr>
  <td>_:x owl11:inverseObjectPropertyExpression y</td>
  <td class="name">InverseObjectProperty( OP(y) )</td>
</tr>
</table>
</div>

<div style="text-align: center">
<table border="2" cellpadding="5">
<caption><span class="caption">Table 5.</span> Translation of Triples to Data Ranges</caption>
<tr>
  <th>Pattern</th>
  <th>Data Range</th>
</tr>
<tr>
  <td>
    _:x rdf:type owl:DataRange<br>
    _:x owl:complementOf y
  </td>
  <td class="name">DataComplementOf( DRANGE(y) )</td>
</tr>
<tr>
  <td>
    _:x rdf:type owl:DataRange<br>
    _:x owl:oneOf T(SEQ ct<sub>1</sub> ... ct<sub>n</sub>)
  </td>
  <td class="name">DataOneOf( ct<sub>1</sub> ... ct<sub>n</sub> )</td>
</tr>
<tr>
  <td>
    _:x rdf:type owl:DataRange<br>
    _:x owl11:onDataRange y<br>
    _:x owl11:<i>facet</i> ct
  </td>
  <td class="name">DatatypeRestriction( DRANGE(y) facet ct )</td>
</tr>
</table>
</div>


<div style="text-align: center">
<table border="2" cellpadding="5">
<caption><span class="caption">Table 6.</span> Translation of Triples to Descriptions</caption>
<tr>
  <th>Pattern</th>
  <th>Description</th>
</tr>
<tr>
  <td>
    _:x rdf:type owl:Class<br>
    _:x owl:unionOf T(SEQ y<sub>1</sub> ... y<sub>n</sub>)
  </td>
  <td class="name">ObjectUnionOf( DESC(y<sub>1</sub>) ... DESC(y<sub>n</sub>) )</td>
</tr>
<tr>
  <td>
    _:x rdf:type owl:Class<br>
    _:x owl:intersectionOf T(SEQ y<sub>1</sub> ... y<sub>n</sub>)
  </td>
  <td class="name">ObjectIntersectionOf( DESC(y<sub>1</sub>) ... DESC(y<sub>n</sub>) )</td>
</tr>
<tr>
  <td>
    _:x rdf:type owl:Class<br>
    _:x owl:complementOf y
  </td>
  <td class="name">ObjectComplementOf( DESC(y) )</td>
</tr>
<tr>
  <td>
    _:x rdf:type owl:Class<br>
    _:x owl:oneOf T(SEQ !y<sub>1</sub> ... !y<sub>n</sub>)
  </td>
  <td class="name">ObjectOneOf( y<sub>1</sub> ... y<sub>n</sub> )</td>
</tr>
<tr>
  <td>
    _:x rdf:type owl11:SelfRestriction<br>
    _:x owl:onProperty y<br>
  </td>
  <td class="name">ObjectExistsSelf( OP(y) )</td>
</tr>
<tr>
  <td>
    _:x rdf:type owl11:ObjectRestriction<br>
    _:x owl:onProperty y<br>
    _:x owl:hasValue !z
  </td>
  <td class="name">ObjectHasValue( OP(y) z )</td>
</tr>
<tr>
  <td>
    _:x rdf:type owl:Restriction<br>
    _:x owl:onProperty y<br>
    _:x owl:hasValue !z<br>
    { OnlyOP(y) = true }
  </td>
  <td class="name">ObjectHasValue( OP(y) z )</td>
</tr>
<tr>
  <td>
    _:x rdf:type owl11:ObjectRestriction<br>
    _:x owl:onProperty y<br>
    _:x owl:someValuesFrom z
  </td>
  <td class="name">ObjectSomeValuesFrom( OP(y) DESC(z) )</td>
</tr>
<tr>
  <td>
    _:x rdf:type owl:Restriction<br>
    _:x owl:onProperty y<br>
    _:x owl:someValuesFrom z<br>
    { OnlyOP(y) = true }
  </td>
  <td class="name">ObjectSomeValuesFrom( OP(y) DESC(z) )</td>
</tr>
<tr>
  <td>
    _:x rdf:type owl11:ObjectRestriction<br>
    _:x owl:onProperty y<br>
    _:x owl:allValuesFrom z
  </td>
  <td class="name">ObjectAllValuesFrom( OP(y) DESC(z) )</td>
</tr>
<tr>
  <td>
    _:x rdf:type owl:Restriction<br>
    _:x owl:onProperty y<br>
    _:x owl:allValuesFrom z<br>
    { OnlyOP(y) = true }
  </td>
  <td class="name">ObjectAllValuesFrom( OP(y) DESC(z) )</td>
</tr>
<tr>
  <td>
    _:x rdf:type owl11:ObjectRestriction<br>
    _:x owl:minCardinality "n"^^xsd:nonNegativeInteger<br>
    _:x owl:onProperty y<br>
    [ _:x owl11:onClass z ]
  </td>
  <td class="name">ObjectMinCardinality( n OP(y) [ DESC(z) ] )</td>
</tr>
<tr>
  <td>
    _:x rdf:type owl:Restriction<br>
    _:x owl:minCardinality "n"^^xsd:nonNegativeInteger<br>
    _:x owl:onProperty y<br>
    [ _:x owl11:onClass z ]<br>
    { OnlyOP(y) = true }
  </td>
  <td class="name">ObjectMinCardinality( n OP(y) [ DESC(z) ] )</td>
</tr>
<tr>
  <td>
    _:x rdf:type owl11:ObjectRestriction<br>
    _:x owl:maxCardinality "n"^^xsd:nonNegativeInteger<br>
    _:x owl:onProperty y<br>
    [ _:x owl11:onClass z ]
  </td>
  <td class="name">ObjectMaxCardinality( n OP(y) [ DESC(z) ] )</td>
</tr>
<tr>
  <td>
    _:x rdf:type owl:Restriction<br>
    _:x owl:maxCardinality "n"^^xsd:nonNegativeInteger<br>
    _:x owl:onProperty y<br>
    [ _:x owl11:onClass z ]<br>
    { OnlyOP(y) = true }
  </td>
  <td class="name">ObjectMaxCardinality( n OP(y) [ DESC(z) ] )</td>
</tr>
<tr>
  <td>
    _:x rdf:type owl11:ObjectRestriction<br>
    _:x owl:cardinality "n"^^xsd:nonNegativeInteger<br>
    _:x owl:onProperty y<br>
    [ _:x owl11:onClass z ]
  </td>
  <td class="name">ObjectExactCardinality( n OP(y) [ DESC(z) ] )</td>
</tr>
<tr>
  <td>
    _:x rdf:type owl:Restriction<br>
    _:x owl:cardinality "n"^^xsd:nonNegativeInteger<br>
    _:x owl:onProperty y<br>
    [ _:x owl11:onClass z ]<br>
    { OnlyOP(y) = true }
  </td>
  <td class="name">ObjectExactCardinality( n OP(y) [ DESC(z) ] )</td>
</tr>
<tr>
  <td>
    _:x rdf:type owl11:DataRestriction<br>
    _:x owl:onProperty y<br>
    _:x owl:hasValue ct
  </td>
  <td class="name">DataHasValue( DP(y) ct )</td>
</tr>
<tr>
  <td>
    _:x rdf:type owl:Restriction<br>
    _:x owl:onProperty y<br>
    _:x owl:hasValue ct<br>
    { OnlyDP(y) = true }
  </td>
  <td class="name">DataHasValue( DP(y) ct )</td>
</tr>
<tr>
  <td>
    _:x rdf:type owl11:DataRestriction<br>
    _:x owl:onProperty y<br>
    _:x owl:someValuesFrom z
  </td>
  <td class="name">DataSomeValuesFrom( DP(y) DRANGE(z) )</td>
</tr>
<tr>
  <td>
    _:x rdf:type owl:Restriction<br>
    _:x owl:onProperty y<br>
    _:x owl:someValuesFrom z<br>
    { OnlyDP(y) = true }
  </td>
  <td class="name">DataSomeValuesFrom( DP(y) DRANGE(z) )</td>
</tr>
<tr>
  <td>
    _:x rdf:type owl11:DataRestriction<br>
    _:x owl:onProperty T(SEQ y<sub>1</sub> ... y<sub>n</sub>)<br>
    _:x owl:someValuesFrom z
  </td>
  <td class="name">DataSomeValuesFrom( DP(y<sub>1</sub>) ... DP(y<sub>n</sub>) DRANGE(z) )</td>
</tr>
<tr>
  <td>
    _:x rdf:type owl:Restriction<br>
    _:x owl:onProperty T(SEQ y<sub>1</sub> ... y<sub>n</sub>)<br>
    _:x owl:someValuesFrom z<br>
    { OnlyDP(y) = true }
  </td>
  <td class="name">DataSomeValuesFrom( DP(y<sub>1</sub>) ... DP(y<sub>n</sub>) MDRANGE(z) )</td>
</tr>
<tr>
  <td>
    _:x rdf:type owl11:DataRestriction<br>
    _:x owl:onProperty y<br>
    _:x owl:allValuesFrom z
  </td>
  <td class="name">DataAllValuesFrom( DP(y) DRANGE(z) )</td>
</tr>
<tr>
  <td>
    _:x rdf:type owl:Restriction<br>
    _:x owl:onProperty y<br>
    _:x owl:allValuesFrom z<br>
    { OnlyDP(y) = true }
  </td>
  <td class="name">DataAllValuesFrom( DP(y) DRANGE(z) )</td>
</tr>
<tr>
  <td>
    _:x rdf:type owl11:DataRestriction<br>
    _:x owl:onProperty T(SEQ y<sub>1</sub> ... y<sub>n</sub>)<br>
    _:x owl:allValuesFrom z
  </td>
  <td class="name">DataAllValuesFrom( DP(y<sub>1</sub>) ... DP(y<sub>n</sub>) DRANGE(z) )</td>
</tr>
<tr>
  <td>
    _:x rdf:type owl:Restriction<br>
    _:x owl:onProperty T(SEQ y<sub>1</sub> ... y<sub>n</sub>)<br>
    _:x owl:allValuesFrom z<br>
    { OnlyDP(y) = true }
  </td>
  <td class="name">DataAllValuesFrom( DP(y<sub>1</sub>) ... DP(y<sub>n</sub>) DRANGE(z) )</td>
</tr>
<tr>
  <td>
    _:x rdf:type owl11:DataRestriction<br>
    _:x owl:minCardinality "n"^^xsd:nonNegativeInteger<br>
    _:x owl:onProperty y<br>
    [ _:x owl11:onDataRange z ]
  </td>
  <td class="name">DataMinCardinality( n DP(y) [ DRANGE(z) ] )</td>
</tr>
<tr>
  <td>
    _:x rdf:type owl:Restriction<br>
    _:x owl:minCardinality "n"^^xsd:nonNegativeInteger<br>
    _:x owl:onProperty y<br>
    [ _:x owl11:onDataRange z ]<br>
    { OnlyDP(y) = true }
  </td>
  <td class="name">DataMinCardinality( n DP(y) [ DRANGE(z) ] )</td>
</tr>
<tr>
  <td>
    _:x rdf:type owl11:DataRestriction<br>
    _:x owl:maxCardinality "n"^^xsd:nonNegativeInteger<br>
    _:x owl:onProperty y<br>
    [ _:x owl11:onDataRange z ]
  </td>
  <td class="name">DataMaxCardinality( n DP(y) [ DRANGE(z) ] )</td>
</tr>
<tr>
  <td>
    _:x rdf:type owl:Restriction<br>
    _:x owl:maxCardinality "n"^^xsd:nonNegativeInteger<br>
    _:x owl:onProperty y<br>
    [ _:x owl11:onDataRange z ]<br>
    { OnlyDP(y) = true }
  </td>
  <td class="name">DataMaxCardinality( n DP(y) [ DRANGE(z) ] )</td>
</tr>
<tr>
  <td>
    _:x rdf:type owl11:DataRestriction<br>
    _:x owl:cardinality "n"^^xsd:nonNegativeInteger<br>
    _:x owl:onProperty y<br>
    [ _:x owl11:onDataRange z ]
  </td>
  <td class="name">DataExactCardinality( n DP(y) [ DRANGE(z) ] )</td>
</tr>
<tr>
  <td>
    _:x rdf:type owl:Restriction<br>
    _:x owl:cardinality "n"^^xsd:nonNegativeInteger<br>
    _:x owl:onProperty y<br>
    [ _:x owl11:onDataRange z ]<br>
    { OnlyDP(y) = true }
  </td>
  <td class="name">DataExactCardinality( n DP(y) [ DRANGE(z) ] )</td>
</tr>
</table>
</div>

<p>The ontology <span class="name">O</span>, corresponding to the set of RDF
triples <span class="name">G</span>, is the samllest set containing the axioms
occurring in the second column of Table 7 for each triple pattern from the first column.</p>

<div style="text-align: center">
<table border="2" cellpadding="5">
<caption><span class="caption">Table 7.</span> Translation of Triples to Axioms</caption>
<tr>
  <th>Pattern</th>
  <th>Axiom</th>
</tr>
<tr>
  <td>
    !x !y<sub>i</sub> ct<sub>i</sub> &nbsp; for 1 &#8804; i &#8804; n<br>
    { owl:Datatype &isin; Type(x) and OnlyAP(y<sub>i</sub>) = true for 1 &#8804; i &#8804; }
  </td>
  <td class="name">
    EntityAnnotation( Datatype(x)<br>
    &nbsp;&nbsp;Annotation( y<sub>1</sub> ct<sub>1</sub> ) ... Annotation( y<sub>n</sub> ct<sub>n</sub> ) )
  </td>
</tr>
<tr>
  <td>
    !x !y<sub>i</sub> ct<sub>i</sub> &nbsp; for 1 &#8804; i &#8804; n<br>
    { owl:Class &isin; Type(x) and OnlyAP(y<sub>i</sub>) = true for 1 &#8804; i &#8804; }
  </td>
  <td class="name">
    EntityAnnotation( OWLClass(x)<br>
    &nbsp;&nbsp;Annotation( y<sub>1</sub> ct<sub>1</sub> ) ... Annotation( y<sub>n</sub> ct<sub>n</sub> ) )
  </td>
</tr>
<tr>
  <td>
    !x !y<sub>i</sub> ct<sub>i</sub> &nbsp; for 1 &#8804; i &#8804; n<br>
    { owl:ObjectProperty &isin; Type(x) and OnlyAP(y<sub>i</sub>) = true for 1 &#8804; i &#8804; }
  </td>
  <td class="name">
    EntityAnnotation( ObjectProperty(x)<br>
    &nbsp;&nbsp;Annotation(a y<sub>1</sub> ct<sub>1</sub> ) ... Annotation( y<sub>n</sub> ct<sub>n</sub> ) )
  </td>
</tr>
<tr>
  <td>
    !x !y<sub>i</sub> ct<sub>i</sub> &nbsp; for 1 &#8804; i &#8804; n<br>
    { owl:DatatypeProperty &isin; Type(x) and OnlyAP(y<sub>i</sub>) = true for 1 &#8804; i &#8804; }
  </td>
  <td class="name">
    EntityAnnotation( DataProperty(x)<br>
    &nbsp;&nbsp;Annotation( y<sub>1</sub> ct<sub>1</sub> ) ... Annotation( y<sub>n</sub> ct<sub>n</sub> ) )
  </td>
</tr>
<tr>
  <td>
    !x !y<sub>i</sub> ct<sub>i</sub> &nbsp; for 1 &#8804; i &#8804; n<br>
    { owl11:Individual &isin; Type(x) and OnlyAP(y<sub>i</sub>) = true for 1 &#8804; i &#8804; }
  </td>
  <td class="name">
    EntityAnnotation( Individual(x)<br>
    &nbsp;&nbsp;Annotation( y<sub>1</sub> ct<sub>1</sub> ) ... Annotation( y<sub>n</sub> ct<sub>n</sub> ) )
  </td>
</tr>
<tr>
  <td>x rdfs:subClassOf y</td>
  <td class="name">SubClassOf( DESC(x) DESC(y) )</td>
</tr>
<tr>
  <td>x owl:equivalentClass y</td>
  <td class="name">EquivalentClasses( DESC(x) DESC(y) )</td>
</tr>
<tr>
  <td>x owl:disjointWith y</td>
  <td class="name">DisjointClasses( DESC(x) DESC(y) )</td>
</tr>
<tr>
  <td>x owl11:disjointUnionOf T(SEQ y<sub>1</sub> ... y<sub>n</sub>)</td>
  <td class="name">DisjointUnion( DESC(x) DESC(y<sub>1</sub>) ... DESC(y<sub>n</sub>) )</td>
</tr>
<tr>
  <td>x owl11:subObjectPropertyOf y</td>
  <td class="name">SubObjectPropertyOf( OP(x) OP(y) )</td>
</tr>
<tr>
  <td>
    x owl11:subObjectPropertyOf y<br>
    { OnlyOP(x) = true and OnlyOP(y) = true }
  </td>
  <td class="name">SubObjectPropertyOf( OP(x) OP(y) )</td>
</tr>
<tr>
  <td>T(SEQ x<sub>1</sub> ... x<sub>n</sub>) owl11:subObjectPropertyOf y</td>
  <td class="name">
    SubObjectPropertyOf(<br>
    &nbsp;&nbsp;subObjectPropertyChain( OP(x<sub>1</sub>) ... OP(x<sub>n</sub>) ) OP(y) )
  </td>
</tr>
<tr>
  <td>
    T(SEQ x<sub>1</sub> ... x<sub>n</sub>) rdfs:subPropertyOf y<br>
    { OnlyOP(x<sub>1</sub>) = true for each 1 &#8804; i &#8804; n, and OnlyOP(y) = true }
  </td>
  <td class="name">
    SubObjectPropertyOf(<br>
    &nbsp;&nbsp;subObjectPropertyChain( OP(x<sub>1</sub>) ... OP(x<sub>n</sub>) ) OP(y) )
  </td>
</tr>
<tr>
  <td>x owl11:equivalentObjectProperty y</td>
  <td class="name">EquivalentObjectProperties( OP(x) OP(y) )</td>
</tr>
<tr>
  <td>
    x owl:equivalentProperty y<br>
    { OnlyOP(x) = true and OnlyOP(y) = true }
  </td>
  <td class="name">EquivalentObjectProperties( OP(x) OP(y) )</td>
</tr>
<tr>
  <td>x owl11:disjointObjectProperties y</td>
  <td class="name">DisjointObjectProperties( OP(x) OP(y) )</td>
</tr>
<tr>
  <td>x owl11:objectPropertyDomain y</td>
  <td class="name">ObjectPropertyDomain( OP(x) DESC(y) )</td>
</tr>
<tr>
  <td>
    x rdfs:domain y<br>
    { OnlyOP(x) = true }
  </td>
  <td class="name">ObjectPropertyDomain( OP(x) DESC(y) )</td>
</tr>
<tr>
  <td>x owl11:objectPropertyRange y</td>
  <td class="name">ObjectPropertyRange( OP(x) DESC(y) )</td>
</tr>
<tr>
  <td>
    x rdfs:range y<br>
    { OnlyOP(x) = true }
  </td>
  <td class="name">ObjectPropertyRange( OP(x) DESC(y) )</td>
</tr>
<tr>
  <td>x owl:inverseOf y</td>
  <td class="name">InverseObjectProperties( OP(x) OP(y) )</td>
</tr>
<tr>
  <td>x rdf:type owl:TransitiveProperty</td>
  <td class="name">TransitiveObjectProperty( OP(x) )</td>
</tr>
<tr>
  <td>x rdf:type owl11:FunctionalObjectProperty</td>
  <td class="name">FunctionalObjectProperty( OP(x) )</td>
</tr>
<tr>
  <td>
    x rdf:type owl:FunctionalProperty<br>
    { OnlyOP(x) = true }
  </td>
  <td class="name">FunctionalObjectProperty( OP(x) )</td>
</tr>
<tr>
  <td>x rdf:type owl:InverseFunctionalProperty</td>
  <td class="name">InverseFunctionalObjectProperty( OP(x) )</td>
</tr>
<tr>
  <td>x rdf:type owl11:ReflexiveProperty</td>
  <td class="name">ReflexiveObjectProperty( OP(x) )</td>
</tr>
<tr>
  <td>x rdf:type owl11:IrreflexiveProperty</td>
  <td class="name">IrreflexiveObjectProperty( OP(x) )</td>
</tr>
<tr>
  <td>x rdf:type owl:SymmetricProperty</td>
  <td class="name">SymmetricObjectProperty( OP(x) )</td>
</tr>
<tr>
  <td>x rdf:type owl11:AsymmetricProperty</td>
  <td class="name">AsymmetricObjectProperty( OP(x) )</td>
</tr>
<tr>
  <td>x owl11:subDataPropertyOf y</td>
  <td class="name">SubDataPropertyOf( DP(x) DP(y) )</td>
</tr>
<tr>
  <td>
    x rdfs:subPropertyOf y<br>
    { OnlyDP(x) = true and OnlyDP(y) = true }
  </td>
  <td class="name">SubDataPropertyOf( DP(x) DP(y) )</td>
</tr>
<tr>
  <td>x owl11:equivalentDataProperty y</td>
  <td class="name">EquivalentDataProperties(dp<sub>1</sub> ... dp<sub>n</sub>)</td>
</tr>
<tr>
  <td>
    x owl:equivalentProperty y<br>
    { OnlyDP(x) = true and OnlyDP(y) = true }
  </td>
  <td class="name">EquivalentDataProperties(dp<sub>1</sub> ... dp<sub>n</sub>)</td>
</tr>
<tr>
  <td>x owl11:disjointDataProperties y</td>
  <td class="name">DisjointDataProperties( DP(x) DP(y) )</td>
</tr>
<tr>
  <td>x owl11:dataPropertyDomain y</td>
  <td class="name">DataPropertyDomain( DP(x) DESC(y) )</td>
</tr>
<tr>
  <td>
    x rdfs:domain y<br>
    { OnlyDP(x) = true }
  </td>
  <td class="name">DataPropertyDomain( DP(x) DESC(y) )</td>
</tr>
<tr>
  <td>x owl11:dataPropertyRange y</td>
  <td class="name">DataPropertyRange( DP(x) DRANGE(y) )</td>
</tr>
<tr>
  <td>
    x rdfs:range y<br>
    { OnlyDP(x) = true }
  </td>
  <td class="name">DataPropertyRange( DP(x) DRANGE(y) )</td>
</tr>
<tr>
  <td>x rdf:type owl11:FunctionalDataPropety</td>
  <td class="name">FunctionalDataProperty( DP(x) )</td>
</tr>
<tr>
  <td>
    x rdf:type owl:FunctionalPropety<br>
    { OnlyDP(x) = true }
  </td>
  <td class="name">FunctionalDataProperty( DP(x) )</td>
</tr>
<tr>
  <td>!x owl:sameAs !y</td>
  <td class="name">SameIndividual( x y )</td>
</tr>
<tr>
  <td>!x owl:differentFrom !y</td>
  <td class="name">DifferentIndividuals( x y )</td>
</tr>
<tr>
  <td>
    !x rdf:type y<br>
    { y is not a part of RDF(S) or OWL 1.1 vocabulary }
  </td>
  <td class="name">ClassAssertion( x DESC(y) )</td>
</tr>
<tr>
  <td>
    !x !y !z<br>
    { none of x, y, and z is a part of RDF(S) or OWL 1.1 vocabulary }<br>
    { <i>owl:AnnotationProperty</i> is not in Type(y) }
  </td>
  <td class="name">ObjectPropertyAssertion( OP(y) x z )</td>
</tr>
<tr>
  <td>
    _:x rdf:type owl11:NegativeObjectPropertyAssertion<br>
    _:x rdf:subject !w<br>
    _:x rdf:predicate !y<br>
    _:x rdf:object !z
  </td>
  <td class="name">NegativeObjectPropertyAssertion( OP(y) w z )</td>
</tr>
<tr>
  <td>
    !x !y ct<br>
    { neither x not y is a part of RDF(S) or OWL 1.1 vocabulary }<br>
    { <i>owl:AnnotationProperty</i> is not in Type(y) }
  </td>
  <td class="name">DataPropertyAssertion( DP(y) x ct )</td>
</tr>
<tr>
  <td>
    _:x rdf:type owl11:NegativeDataPropertyAssertion<br>
    _:x rdf:subject !w<br>
    _:x rdf:predicate !y<br>
    _:x rdf:object ct
  </td>
  <td class="name">NegativeDataPropertyAssertion( DP(y) w ct )</td>
</tr>
<tr>
  <td>
    !x owl11:declaredAs owl:Datatype
  </td>
  <td class="name">
    Declaration( Datatype(x) )
  </td>
</tr>
<tr>
  <td>
    !x owl11:declaredAs owl:Class
  </td>
  <td class="name">
    Declaration( OWLClass(x) )
  </td>
</tr>
<tr>
  <td>
    !x owl11:declaredAs owl:ObjectProperty
  </td>
  <td class="name">
    Declaration( ObjectProperty(x) )
  </td>
</tr>
<tr>
  <td>
    !x owl11:declaredAs owl:DatatypeProperty
  </td>
  <td class="name">
    Declaration( DataProperty(x) )
  </td>
</tr>
<tr>
  <td>
    !x owl11:declaredAs owl11:Individual
  </td>
  <td class="name">
    Declaration( Individual(x) )
  </td>
</tr>
<tr>
  <td>
    _:x rdf:type owl11:Axiom<br>
    _:x !y<sub>i</sub> ct<sub>i</sub> &nbsp; 1 &#8804; i &#8804; n<br>
    _:x rdf:subject s<br>
    _:x rdf:predicate !p<br>
    _:x rdf:object o<br>
  </td>
  <td>
    The result is the axiom obtained by matching the triple pattern <span class="name">s p o</span>.<br>
    The axiom contains the following annotations:<br>
    <span class="name">Annotation( y<sub>1</sub> ct<sub>1</sub> ) ... Annotation( y<sub>n</sub> ct<sub>n</sub> ) )</span>
  </td>
</tr>
</table>
</div>

<p>If <span class="name">G</span> contains some triple that is not matched by any triple pattern
(including the patterns used to define <span class="name">Type(x)</span>), then
<span class="name">G</span> cannot be translated into an OWL 1.1 ontology.</p>


<hr>

<h2><a id="References" name="References">References</a></h2>
<dl>

  <dt><a id="ref-owl-1.1-specification">[OWL 1.1 Specification]</a></dt>
  <dd>
    <cite><a href="owl_specification.html">OWL 1.1 Web Ontology Language: Structural Specification and Functional-Style Syntax</a></cite>.
    Peter F. Patel-Schneider, Ian Horrocks, and Boris Motik, eds., 2006.
  </dd>

  <dt><a id="ref-owl-1.1-semantics">[OWL 1.1 Semantics]</a></dt>
  <dd>
    <cite><a href="semantics.html">OWL 1.1 Web Ontology Language: Model-Theoretic Semantics</a></cite>.
    Bernardo Cuenca Grau and Boris Motik, eds., 2006.
  </dd>

  <dt><a id="ref-rdf-semantics">[RDF Semantics]</a></dt>
  <dd>
    <cite><a href="http://www.w3.org/TR/rdf-mt/">RDF Semantics</a></cite>.
    Patrick Hayes, Editor, W3C Recommendation, 10 February 2004, http://www.w3.org/TR/2004/REC-rdf-mt-20040210/.
  </dd>

</dl>

</body>
</html>
