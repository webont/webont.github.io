<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">

<html lang="en-us">
<head>
<meta content="text/html; charset=ISO-8859-1" http-equiv="content-type">

<link href="primer_files/owl.css" type="text/css" rel="stylesheet">
<link rel="stylesheet" type="text/css" href="primer_files/W3C-Member-SUBM">
<link href="http://www.cs.man.ac.uk/%7Ebparsia/owl/temp/images/owl-icon.png"
	rel="shortcut icon">

<link rel="stylesheet" type="text/css" href="dl-tabbed.css" />
<script type="text/javascript" src="dl-tabbed.js" />


<title>OWL 1.1 Web Ontology Language:</title>
</head>

<body>

<div class="head">

<h1 class="mainTitle">
<br />
</h1>

<h1 class="mainTitle">
<img style="float: right; height: 200px;" alt="owl" src="primer2_files/owl.png">
OWL 1.1 Web Ontology Language<br />

Primer</h1>

<h2>
<a id="editordraft" name="editordraft">
</a>Editor's
Draft of 14 Dec 2007</h2>
<dl>
<dt>Latest version: </dt>
<dd>TODAY</dd>
<dt>This version: </dt>
<dd>TODAY</dd>
<dt>Editors:</dt>
<dd>Bijan Parsia, Peter F. Patel-Schneider</dd>
</dl>
<p class="copyright">
Copyright © 2007 by the Editors. This document is available under the
@@
</p>
</div>
<hr />
<div class="abstract">
<h2 class="notoc"><a id="abstract" name="abstract">Abstract</a></h2>
<p>The W3C OWL 1.1 Web Ontology Language is designed to represent
ontological information about individuals, classes, and properties in a
Semantic Web setting.
OWL provides a rich language for structuring and classifying with both
complete and incomplete information.
This short primer provides an approachable introduction to OWL 1.1,
including orientation for those coming from other disciplines, an
example showing how OWL 1.1 can be used to represent first simple
information and then more complex information, how OWL 1.1 manages
ontologies, and finally the distinctions between the various
sublanguages of OWL 1.1.
</p>
</div>
<div class="status">
<h2 class="notoc"><a id="status" name="status">Status
of this Document</a></h2>
<p><strong>This is an editor's draft.</strong></p>
<p>
This document is being prepared for consideration by the <a href="http://www.w3.org/2007/OWL/wiki/OWL_Working_Group">W3C
OWL WG</a>.
Comments are welcome.
Please send feedback to <a href="mailto:public-owl-dev@w3.org">public-owl-dev@w3.org</a>,
which has a
<a href="http://lists.w3.org/Archives/Public/public-owl-dev/">public
archive</a>.</p>
</div>
<hr />

<div class="toc">
<h2 class="notoc"><a id="toc" name="toc">Table of Contents</a></h2>
<ul class="toc">
<li class="tocline1"><a href="#1">1 Introduction</a></li>
<li class="tocline1"><a href="#2">2 Orientation</a></li>
<ul>
<li class="tocline1">Technology Perspectives</li>
<ul>
<li class="tocline1">OWL from an XML perspective</li>
<li class="tocline1">OWL from a RDF perspective</li>
<li class="tocline1">OWL from a database perspective</li>
<li class="tocline1">OOP programmer perspective</li>
</ul>
<li class="tocline1">Application perspectives</li>
<ul>
<li class="tocline1">HCLS/Scientific</li>
<li class="tocline1">Information Integration</li>
</ul>
</ul>
<li class="tocline1"><a href="#basic">3 Basic Notions</a></li>
<li class="tocline1"><a href="#advanced">4 Advanced Notions</a></li>
<li class="tocline1"><a href="#ontologies">5 Ontology Management</a></li>
<li class="tocline1"><a href="#remaining">6 Remaining Constructs</a></li>
<li class="tocline1"><a href="#species">7 OWL Species</a></li>
<li class="tocline1"><a href="#next">8 What to Read Next</a></li>
<li class="tocline1"><a href="#example">9 The Complete Example</a></li>
<li class="tocline1"><a href="#references">References</a></li>
</ul>
</div>
<hr />
<h2><a name="1"></a>1 Introduction</h2>
<p>
The W3C OWL 1.1 Web Ontology Language (OWL) is a
Semantic Web language designed to represent ontologies - information
about how individuals fit together in a particular domain. OWL can
represent rich and complex information about classes of individuals and
their properties. OWL is a logical language, where every construct
has a well-defined formal meaning that fit together to support exact
and
useful representation of many different kinds of information. OWL
groups information into formal ontologies, which can be stored and
transmitted in the World Wide Web in the same way that data and other
kinds of information are.
</p>
<p>
This short primer contains, first, orientations to OWL for various
communities, including XML, RDF, databases, and object-oriented
programming. The bulk of the prime consists of an example that
illustrates the different kinds of information that can be represented
in OWL. The primer then describes how OWL packages information into
ontologies and how extra non-logical information is associated with
parts of an ontology. Finally, the primer describes the various
sublanguages of OWL, and what is gained and lost by using them.
</p>
<hr />
<h2><a name="2"></a>2 Orientation</h2>
<p>OWL
is superficially similar to many other technologies, which is not too
surprising given the prevelance of XML as a concrete syntax and of the
class-object paradigm. People familiar with other technologies are
sometimes misled by the similarities and thus very surprised by the
differences. In section 2.1, we provide a brief orientation to OWL from
a number of prominent technological perspectives. At various points in
the tutorial sections of this Primer, we shall highlight aspects of OWL
that might be surprising to people coming from these perspectives.</p>
<p>In section 2.2, we briefly discuss some major ways of using
OWL in
applications.</p>
<h3>2.1 Technologies</h3>
<hr size="2" width="100%">
<p><b>RDF</b>: Of
the technologies discussed in this section, RDF(S) is the closest to
OWL. They both have roots in logic based knowledge representation; in
many ways, RDF(S) can be seen as a subset of OWL; and, perhaps most
prominently, the primary exchange syntax for OWL has been RDF/XML.
However, there are differences of style, emphasis, and common practice
that can make relying on RDF(S) intuitions misleading when working with
OWL. For example, while OWL statements and expressions can be encoded
as RDF triples, the triple view is not typically a fruitful way of
writing or understanding complex expressions. Similarly, it is fairly
common and effective to work with RDF as a graph data structure or
database where the primary focus is on the explicit statements in the
graph. Even when we consider parts of RDFS which support
implicit
knowledge, such as subclass inheritance, the relation between the
explicit and implicit statements is very direct. Thus, it is easy to
conceptualize inference in terms of graph structure manipulation.</p>
<p>In
contrast, OWL allows for -- and encourages -- operations that are not
rooted so directly in the evident structure of an ontology.</p>
<hr size="2" width="100%">
<p><b>XML:</b> OWL
and the XML family of technologies share some common parts: OWL can be
expressed in XML languages (such as [] and RDF/XML) and thus be
manipulated by XML tools. OWL reuses datatypes and datatype derivation
facets from XML Schema (and can use certain forms of XML Schema type
definitions). Finally, OWL, like XML Schema, both have an object
oriented approach and, to a certain extent, similar missions. Both OWL
and XML Schema can be used for <i>conceptual modeling</i>
as well as data definition, though they ways they go about it are
fairly distinct.</p>
<p>OWL is oriented toward <i>more abstract</i>,
higher level conceptual modeling. It is designed to support the
discovery of relationships between descriptions through automated
reasoning. It also builds in far fewer presumptions about the entities
it is describing both generally and in terms of their physical
realization in computational systems.</p>
<p>XML Schema, on the other
hand, while supporting strong abstraction facilities, is oriented
toward a more concrete level of conceptual<br />
modeling. This is inherent
in its core mission of validating XML documents.</p>
<hr size="2" width="100%"><b>Database</b><br />
<hr size="2" width="100%">
<p><b>OOP</b></p>
<h3>2.2 Applications</h3>
Terminlogy development and managament. Conceptual Modeling.
<hr />
<h2><a name="basic"></a>3 Basic Notions</h2>
<p>
OWL allows us to express <i>information</i> about the
world then to
draw certain <i>consequences</i> based on this
information. There are
OWL tools - reasoners - that can automatically compute these
consequences.
In OWL, we
presume that the world is primarily made up of individual
entities (typically known as <i>individuals</i> or <i>objects</i>).
Individuals are related to each other and to <i>data values</i>
via <i>properties</i>.
Using OWL, we can group individuals that share
certain characteristics into <em>classes</em>. </p>
<p>
OWL is part of the Semantic Web, so names in OWL are international
resource identifiers (IRIs).
As IRIs are long, we will use a compact way of writing them in OWL,
consisting of a prefix and a reference separated by a colon.
When OWL information is transferred around in the Web, it is done as an
XML dialect.  As XML is verbose, there are syntaxes for writing
OWL that are easier for us to read.   There are tools that can translate
between the different syntaxs for OWL.
</p>
<h3>3.1 Simple Information about Individuals</h3>
<p>
Suppose we want to represent information about a particular family.
We first need to determine what individuals there are in a family, and
how they are related to each other and what data values are associated
with them. We can then proceed by writing down all this information in
OWL.
</p>
<p>
So if we have a family with parents <name>John</name> and
<name>Mary</name> and children <name>Susan</name>
and <name>Bill</name>
we could write all this down, along with their <name>age</name>s
as
follows.
</p>

<dl class="tabbed">
<dt>Manchester Syntax</dt>
<dd>
f:John f:hasWife f:Mary <br />
f:John f:hasSon f:Bill <br />
f:Mary f:hasSon f:Bill <br />
f:John f:hasDaughter f:Susan <br />
f:Mary f:hasDaughter f:Susan <br />
f:John f:hasAge "33"^^xsd:integer <br />
f:Mary f:hasAge "31"^^xsd:integer <br />
f:Bill f:hasAge "13"^^xsd:integer <br />
f:Susan f:hasAge "8"^^xsd:integer
</dd>
<dt>Functional-Style Syntax</dt>
<dd>
ObjectPropertyAssertion(f:John f:hasWife f:Mary) <br />
ObjectPropertyAssertion(f:John f:hasSon f:Bill) <br />
ObjectPropertyAssertion(f:Mary f:hasSon f:Bill) <br />
ObjectPropertyAssertion(f:John f:hasDaughter f:Susan) <br />
ObjectPropertyAssertion(f:Mary f:hasDaughter f:Susan) <br />
DataPropertyAssertion(f:John f:hasAge "33"^^xsd:integer) <br />
DataPropertyAssertion(f:Mary f:hasAge "31"^^xsd:integer) <br />
DataPropertyAssertion(f:Bill f:hasAge "13"^^xsd:integer) <br />
DataPropertyAssertion(f:Susan f:hasAge "8"^^xsd:integer)
</dd>
<dt>RDF/XML Syntax</dt>
<dd>
&lt;rdf:Description rdf:about="http://ex.com/owl/families#John"><br />
&nbsp;&nbsp;&lt;f:hasWife rdf:resource="http://ex.com/owl/families#Mary" /><br />
&nbsp;&nbsp;&lt;f:hasSon rdf:resource="http://ex.com/owl/families#Bill" /><br />
&nbsp;&nbsp;&lt;f:hasDaughter rdf:resource="http://ex.com/owl/families#Susan" /><br />
&nbsp;&nbsp;&lt;f:hasAge rdf:datatype="http://www.w3.org/2001/XMLSchema#integer">33&lt;/f:hasage><br />
&lt;/rdf:Description><br />
&lt;rdf:Description rdf:about="http://ex.com/owl/families#Mary"><br />
&nbsp;&nbsp;&lt;f:hasSon rdf:resource="http://ex.com/owl/families#Bill" /><br />
&nbsp;&nbsp;&lt;f:hasDaughter rdf:resource="http://ex.com/owl/families#Susan" /><br />
&nbsp;&nbsp;&lt;f:hasAge rdf:datatype="http://www.w3.org/2001/XMLSchema#integer">31&lt;/f:hasage><br />
&lt;/rdf:Description><br />
&lt;rdf:Description rdf:about="http://ex.com/owl/families#Bill"><br />
&nbsp;&nbsp;&lt;f:hasAge rdf:datatype="http://www.w3.org/2001/XMLSchema#integer">13&lt;/f:hasage><br />
&lt;/rdf:Description><br />
&lt;rdf:Description rdf:about="http://ex.com/owl/families#Susan"><br />
&nbsp;&nbsp;&lt;f:hasAge rdf:datatype="http://www.w3.org/2001/XMLSchema#integer">8&lt;/f:hasage><br />
&lt;/rdf:Description>
</dd>
</dl>

<p>We could also write down information about the sex of people
by
providing them with a <name>gender</name>, which is
either <name>male</name> or <name>female</name>.
</p>
<dl class="tabbed">
<dt>Manchester Syntax</dt>
<dd>
f:John f:hasGender f:male <br />
f:Mary f:hasGender f:female <br />
f:Bill f:hasGender f:male <br />
f:Susan f:hasGender f:female
</dd>
</dl>
<p>However, all we have done so far is written down the basic
facts about a
particular family. Although OWL can be used for this purpose, it is not
OWL's forté. OWL's main strength here, instead, involves how
families work in general.
</p>
<h3>3.2 Information about Properties</h3>
<p>
So let's switch gears and think how families work in general.
(This is the process of knowledge representation. Like all processes
representing information about the world, certain simplifying
assumptions must be made, and since this is a primer we are going to be
simplifying a lot.) Well, the individuals in families are all people,
so we should have a
class of people, with name <name>Person</name>.
We have already written down information about several properties.
<name>wife</name> is a relationship between <name>Person</name>s,
i.e., both the domain and range of <name>wife</name> is <name>Person</name>,
as are both <name>son</name> and <name>daughter</name>.
<name>age</name> is a relationship from a <name>Person</name>
to an
integer.
</p>
<dl class="tabbed">
<dt>Manchester Syntax</dt>
<dd>
Class: f:Person <br />
ObjectProperty: f:hasWife domain: f:Person range: f:Person <br />
ObjectProperty: f:hasSon domain: f:Person range: f:Person <br />
ObjectProperty: f:hasDaughter domain: f:Person range: f:Person <br />
DataProperty: f:hasAge domain: f:Person range: xsd:integer
</dd>
<dt>Functional-Style Syntax</dt>
<dd>
ObjectPropertyDomain(f:hasWife f:Person)<br />
ObjectPropertyRange(f:hasWife f:Person)<br />
ObjectPropertyDomain(f:hasSon f:Person)<br />
ObjectPropertyRange(f:hasSon f:Person)<br />
ObjectPropertyDomain(f:hasDaughter f:Person)<br />
ObjectPropertyRange(f:hasDaughter f:Person)<br />
DataPropertyDomain(f:hasAge f:Person)<br />
DataPropertyRange(f:hasAge xsd:integer)
</dd>
</dl>

<p>From this information we can conclude that <name>John</name>
belongs to
<name>Person</name>, because, for example, the domain of
<name>wife</name> is <name>Person</name> and <name>John</name>
has a
<name>wife</name>.
We can also directly state that an individual belongs to a class.
</p>
<dl class="tabbed">
<dt>Manchester Syntax</dt>
<dd>
Individual: f:John f:Person
</dd>
<dt>Functional-Style Syntax</dt>
<dd>
ClassAssertion(f:John f:Person)
</dd>
</dl>
<p>There is more that can be said even about just this little
part of
familial relationships.
For example, the inverse of the <name>wife</name> property
is
<name>husband</name>.
As well, <name>son</name> and <name>daughter</name>
are specializations
of the <name>child</name> relationship.
Further, no individual can be both a <name>son</name> and
a
<name>daughter</name>, so these properties are disjoint.
Individuals have at most one <name>age</name>, so
<name>age</name> is a functional data property.
Individuals participate in at most one <name>wife</name>
relationship
and no individual is its own <name>wife</name>,
so <name>wife</name> is functional, and inverse
functional, and irreflexive.
(It is also possible to specify that a property is reflexive, but this
is not commonly done because the property is then reflexive for
<em>all</em> individuals.)
As well, <name>wife</name> is asymmetric.
Note that we have added more information about several properties. It
is perfectly acceptable in OWL to have information about a property
(or class, or individual) occur in several places.
</p>
<dl class="tabbed">
<dt>Manchester Syntax</dt>
<dd>
ObjectProperty: f:hasHusband inverseOf: f:hasWife <br />
ObjectProperty: f:hasChild domain: f:Person range f:Person <br />
ObjectProperty: f:hasSon SubPropertyOf: f:hasChild <br />
ObjectProperty: f:hasDaughter  SubPropertyOf: f:hasChild <br />
DisjointObjectProperties: f:hasSon f:hasDaughter <br />
FunctionalDataProperty: f:hasAge <br />
FunctionalDataProperty: f:hasWife <br />
InverseFunctionalDataProperty: f:hasWife <br />
IrreflexiveFunctionalDataProperty: f:hasWife <br />
AsymmetricFunctionalDataProperty: f:hasWife
</dd>
</dl>

<p>What we have said about families and about our particular
family has a
number of consequences. For example, because <name>husband</name>
is the inverse of
<name>wife</name>, <name>Mary</name>'s <name>husband</name>
is
<name>John</name>.
Complete OWL reasoning tools can efficiently determine whether a
particular consequence follows from the information available.
</p>
<h3>3.3 Information About Classes</h3>
<p>
So far we have written down quite a bit of information about familial
properties, but all we have about the familial classes is that there
are
people.
OWL has a rich language for defining classes.
So we might have classes for men, women, and parents, each of which is
a specialization of <name>Person</name>.
</p>
<dl class="tabbed">
<dt>Manchester Syntax</dt>
<dd>
Class: f:Man SubClassOf: f:Person <br />
Class: f:Woman SubClassOf: f:Person <br />
Class: f:Parent SubClassOf: f:Person
</dd>
</dl>
<p>We can do much more in OWL with classes than just provide
generalizations for them. OWL can provide partial or complete
information about
what is required to belong to a class.
(The constructs used to provide information about classes are called
<em>descriptions</em> in OWL.)
For example, saying that people have exactly one <name>age</name>
and
exactly one <name>gender</name> that is either <name>male</name>
or <name>female</name>
provides (partial) information about people.
Not only saying that every individual that belongs
to <name>Man</name> also belongs to <name>Person</name>,
but also saying
that every <name>Person</name> that has <name>gender</name>
<name>male</name> belongs to <name>man</name>,
and similarly for
<name>Woman</name>, provides complete information about
what it takes to
belong to these two classes.
We can also say that every <name>Person</name> that has at
least one <name>child</name> that
is a <name>Person</name> belongs to <name>Parent</name>.
</p>
<dl class="tabbed">
<dt>Manchester Syntax</dt>
<dd>
Class: f:Person SubClassOf: f:hasAge EXACTLY 1 AND
                              f:hasGender EXACTLY 1 AND
			      f:hasGender ALL { f:male f:female } <br />
Class: f:Man EquivalentTo: f:Person AND f:hasGender VALUE f:male <br />
Class: f:Woman EquivalentTo: f:Person AND f:hasGender VALUE f:female <br />
Class: f:Parent EquivalentTo: f:Person AND f:hasChild MIN 1 f:Parent
</dd>
<dt>Functional-Style Syntax</dt>
<dd>
SubClassOf(f:Person 
    ObjectIntersectionOf(DataExactCardinality(1 f:hasAge) 
                         ObjectExactCardinality(1 f:hasGender) 
			 ObjectAllValuesFrom(f:hasGender ObjectOneOf(f:male f:female)))) <br />
EquivalentClasses(f:Man 
    ObjectIntersection(f:Person ObjectHasValue(f:hasGender f:male))) <br />
EquivalentClasses(f:Woman
    ObjectIntersection(f:Person ObjectHasValue(f:hasGender f:female))) <br />
EquivalentClasses(f:Parent
    ObjectIntersection(f:Person ObjectMinCardinality(1 f:hasChild)))
</dd>
</dl>
<p>Complete definitions enable many consequences in OWL. For
example, from the above <name>John</name> belongs to
<name>Man</name> and <name>Parent</name>. Some
of the consequences can
surprise users, so some OWL tools provide (rudimentary) facilities for
showing how a consequence was determined.
</p>
<p>
In OWL, descriptions can be used just about anywhere a class name can
be
used.
So, for example, we could provide more information about the
<name>wife</name>,
<name>son</name>, and <name>daughter</name>
properties by given them more
specific domains and ranges.
</p>
<dl class="tabbed">
<dt>Manchester Syntax</dt>
<dd>
ObjectProperty: f:hasWife domain: f:Man range: f:Woman <br />
ObjectProperty: f:hasSon domain: f:Parent range: Person AND
f:hasGender f:male <br />
ObjectProperty: f:hasDaughter domain: f:Parent range: Person AND
f:hasGender f:female <br />
</dd>
</dl>
<p>In this case, we could just as well have used <name>Man</name>
and
<name>Woman</name> for the ranges of <name>son</name>
and
<name>daughter</name>. This would provide exactly the same
information
to OWL, and OWL reasoners can determine this.
</p>
<p>
It may seem that there is a circularity in defining <name>Parent</name>
as people with at least one <name>child</name> and also
making it be the
domain of <name>child</name>. In OWL, however, there is no
problem.
The two bits of information are simply different ways of saying the
same
thing.
</p>
<h3>3.4 Data Ranges</h3>
<p>
OWL can also represent information about certain groupings of data
values, called <em>data ranges</em>.
For example, we might have <name>Teenager</name> as those
people whose
<name>age</name> is at least <name>13</name>
but less than
<name>20</name>, <name>Adult</name> as those
people whose
<name>age</name> is at least <name>21</name>,
and <name>Child</name> as
those people whose <name>age</name> is in the complement
of adult ages.
</p>
<dl class="tabbed">
<dt>Manchester Syntax</dt>
<dd>
Class: Teenager SubClassOf: Person AND hasAge SOME xsd:integer
&ge; "13"^^xsd:integer &lt; "20"^^xsd:integer <br />
Class: Adult SubClassOf: Person AND hasAge SOME xsd:integer
&ge; "21"^^xsd:integer <br />
Class: Child SubClassOf: Person AND NOT ( hasAge SOME xsd:integer
&ge; "21"^^xsd:integer )
</dd>
</dl>
<p>From this, <name>Bill</name> belongs to <name>Teenager</name>,
but not
<name>Adult</name>.
Both <name>John</name> and <name>Mary</name>
belong to
<name>Adult</name>, but not to <name>Teenage</name>.
<name>Mary</name> belongs to neither <name>Adult</name>
nor to
<name>Teenage</name>. </p>
TODO: string data ranges??
<hr />
<h2><a name="advanced"></a>4 Advanced Notions</h2>
<h3>4.1 Incomplete Information about Data Values</h3>
<p>
In the example so far, we knew quite a bit of information.
We knew, for example, that <name>John</name>'s (only) <name>age</name>
was 47.
OWL is designed to deal with incomplete information, so it is quite
common in OWL not to know, for example, the <name>age</name>s
of all
individuals belonging to <name>Person</name>, as just
below.
</p>
<dl class="tabbed">
<dt>Manchester Syntax</dt>
<dd>
f:Jeff f:hasWife f:Emily <br />
f:Jeff f:hasChild f:Jack <br />
f:Jeff f:hasChild f:Ellen <br />
f:Jeff f:hasAge "77"^^xsd:integer <br />
</dd>
</dl>
<p>It is a consequence of the above that <name>Jeff</name>
belongs to
<name>Adult</name> and not to <name>Teenager</name>.
However, it cannot be determined whether <name>Emily</name>
or
<name>Jack</name> belong to <name>Adult</name>
or <name>Teenager</name>,
even though they both must have an <name>age</name>.
</p>
<p>
It is also possible to provide partial information about values, as in
saying that <name>Ellen</name>'s <name>age</name>
is between 15 and 21, or
that <name>Emily</name>'s <name>age</name> is
either 39 or 49, or even that
<name>Jeff<name>'s age is not 53.
</name></name></p>
<dl class="tabbed">
<dt>Manchester Syntax</dt>
<dd>
Individual: f:Ellen f:hasAge SOME xsd:integer &ge;
"15"^^xsd:integer &le; "21"^^xsd:integer <br />
Individual: f:Emily f:hasAge VALUE { "39"^^xsd:integer &le;
"49"^^xsd:integer } <br />
f:Jeff NOT f:hasAge "53"^^xsd:integer
</dd>
</dl>
<p>From this it is possible to determine that <name>Emily</name>
belongs to Adult<name>, even though we don't
know her exact age, but we cannot determine that <name>Ellen</name>
belongs to either </name>Adult<name> or
</name>Teenager<name>.
On the other hand, we could have a class <name>YoungChild</name>
that was neither
</name>Adult<name> nor </name>Teenager<name>.
<name>Ellen</name> would then <em>not</em>
belong to this class.
</name></p>
<dl class="tabbed">
<dt>Manchester Syntax</dt>
<dd>
Class: f:YoungChild EquivalentTo: NOT ( f:Teenager OR f:Adult )
</dd>
</dl>
<h3>4.2 Other Incomplete Information</h3>
<p>
There are many sources of incompleteness in OWL, some of which may be
surprising to those not having a logical background.
It may seem that there is complete information about <name>John</name>'s
family but this is <em>not</em> the case.
</p>
<p>
For example, although it may seem to be the case that <name>Jeff</name>
has exactly two children, this is <em>not</em> the case,
nor is it the case that <name>Jeff</name> has only one
<name>child</name> that belongs to <name>Man</name>.
Formally, the following is not a consequence of the above information.
</p>
<dl class="tabbed">
<dt>Manchester Syntax (non-consequence)</dt>
<dd>
Individual: f:Jeff f:Person AND f:hasChild EXACTLY 2 <br />
Individual: f:Jeff f:Person AND f:hasChild MAX 1 f:Man
</dd>
<dt>Functional-Style Syntax (non-consequence)</dt>
<dd></dd>
<dt>RDF/XML Syntax (non-consequence)</dt>
<dd></dd>
</dl>
<p>These do not follow because there is nothing saying that <name>Jack</name>
and <name>Ellen</name> are the only children of
<name>Jeff</name>, and OWL does not make any assumptions
that something
that has not been said is not true.
It is possible to state that <name>Jeff</name> has no
other children,
and this can be done in a number of ways.
One way that is often used for this purpose is to directly say that
<name>Jeff</name> has exactly 2 children, which should
certainly be
adequate to infer that <name>Jeff</name> has exactly 2
children
</p>
<dl class="tabbed">
<dt>Manchester Syntax</dt>
<dd>
Individual: f:Jeff f:hasChild EXACTLY 2
</dd>
</dl>
<h3>4.3 Same and Different Individuals</h3>
<p>
However, even this is not adequate to infer that <name>Jeff</name>
has only one
<name>child</name> that belongs to <name>Man</name>.
We have not stated that <name>Jack</name> and <name>Ellen</name>
are different people, and
there is nothing said so far that implies that they are not the same.
Again OWL does <em>not</em> make the assumption that
different names are
names for different individuals.
(This "unique names assumption" is particularly dangerous in the
Semantic Web, where names may be coined by different organizations at
different times unknowingly referring to the same individual.)
If <name>Jack</name> and <name>Ellen</name> <em>are</em>
the same, then
there could be another <name>child</name> of <name>John</name>,
and this
child could belong to <name>Man</name>.
</p>
<p>
One might think that <name>Jack</name> and <name>Ellen</name>
are
different because they have different <name>gender</name>s,
and people have exactly one <name>gender</name>.
Unfortunately, we have
not stated that <name>male</name> and <name>female</name>
are different.
We could just state that <name>male</name> and <name>female</name>
are
different, and have this imply that <name>Jack</name> and
<name>Ellen</name> are different, but let's add in a
reasonable
collection of information about which names are different.
Note that we don't really have to do this for <name>John</name>'s
family as
their different ages imply that they are all different.
Similarly the wifes and their husbands were already known to be
different, because we already stated that <name>wife</name>
is irreflexive.
</p>
<dl class="tabbed">
<dt>Manchester Syntax</dt>
<dd>
DifferentIndividuals: f:John f:Mary f:Bill f:Bill f:Susan <br />
DifferentIndividuals: f:Jeff f:Emily f:Jack f:Ellen f:Susan <br />
DifferentIndividuals: f:male f:female
</dd>
</dl>
<p>It is also possible to state that two names refer to (denote)
the same
individual. For example, we can say that <name>John</name>
and <name>Jack</name> are the same individual.
</p>
<dl class="tabbed">
<dt>Manchester Syntax</dt>
<dd>
SameIndividual: f:John f:Jack
</dd>
</dl>
<h3>4.4 Disjointness of Classes</h3>
<p>
From the above we can conclude that <name>Man</name> and <name>Woman</name>
are disjoint,
i.e., that they can never have individuals belonging to both of them,
because every <name>Person</name> has exactly one <name>gender</name>
and individuals that belong to <name>Man</name> have a
different <name>gender</name> (<name>male</name>)
from those that belong to <name>Woman</name> (<name>female</name>).
Hoever, we can also use OWL to state that classes are disjoint.
This is most often for classes that lack complete conditions for
belonging to the class. (These classes are called <em>primitive</em>
classes.)
However, for classes that do not have complete conditions, 
for example <name>ReligiousMarriage</name> and
<name>CivilMarriage</name>, we have to directly state their
disjointness, and here we also say that <name>Marriage</name> is the
union of the two.
</p>

<dl class="tabbed">
<dt>Manchester Syntax</dt>
<dd>
Class: f:ReligiousMarriage DisjointWith: f:CivilMarriage <br />
Class: f:Marriage EquivalentTo: f:ReligiousMarriage OR f:CivilMarriage
</dd>
</dl>

<p>
As it is common to have this situation of a class that is the union of a
number of disjoint classes, 
OWL provides a shorthand method for saying this all at once.
</p>

<dl class="tabbed">
<dt>Manchester Syntax</dt>
<dd>
DisjointUnion: f:Marriage f:ReligiousMarriage f:CivilMarriage
</dd>
</dl>

<h3>4.5 More Information About Properties</h3>
<p>
In OWL we can have transitive properties, i.e., properties like
<name>ancestor</name>, which also is a generalization of
the inverse of
the <name>child</name> property, and is also irreflexive.
</p>
<dl class="tabbed">
<dt>Manchester Syntax</dt>
<dd>
TransitiveObjectProperty: f:hasAncestor <br />
IrreflexiveObjectProperty: f:hasAncestor <br />
ObjectProperty: f:hasChild SubPropertyOf: inverseOf f:hasAncestor
</dd>
</dl>
<p>From the above information,
we can now conclude that <name>Bill</name> has <name>Jeff</name>
as an
<name>ancestor</name>, and that <name>Bill</name>
is not his own <name>ancestor</name>.
</p>
<dl class="tabbed">
<dt>Manchester Syntax (consequence)</dt>
<dd>
f:Bill f:hasAncestor f:Jeff <br />
f:Bill NOT f:hasAncestor f:Bill
</dd>
<dt>Functional-Style Syntax (consequence)</dt>
<dd> </dd>
<dt>RDF/XML Syntax (consequence)</dt>
<dd> </dd>
</dd>
</dl>
<p>There are yet other kinds of information that we say provide
for
properties.
We can have a <name>spouse</name> property as a symmetric
and
irreflexive generalization of <name>wife</name>.
</p>
<dl class="tabbed">
<dt>Manchester Syntax</dt>
<dd>
SymmetricObjectProperty: f:hasSpouse <br />
IrreflexiveObjectProperty: f:hasSpouse <br />
ObjectProperty: f:hasWife SubPropertyOf: f:hasSpouse
</dd>
</dl>
<p>Although we haven't directly so stated, we can conclude that
<name>spouse</name> is also a generalization of <name>husband</name>,
because <name>spouse</name> is a symmetric generalization
of the inverse
of <name>husband</name>.
</p>
<p>
We could enrich our example to include a <name>loves</name>
property as a
generalization of the <name>wife</name> property. (Thus
turning our
simplied view of familial relationships into an idealistic one as
well.)
</p>
<dl class="tabbed">
<dt>Manchester Syntax</dt>
<dd>
ObjectProperty: f:loves domain: f:Person <br />
ObjectProperty: f:hasWife SubPropertyOf: f:loves
</dd>
</dl>
<p>Because <name>loves</name> is not symmetric, we
cannot conclude that <name>loves</name> is a
generalization of <name>husband</name>.
We have also not specified whether <name>loves</name> is
reflexive or
not, so some people may love themselves.
We could have <name>Narcissist</name>, those people who
love themselves,
and add some more information about <name>loves</name>
relationships&gt;
</p>
<dl class="tabbed">
<dt>Manchester Syntax</dt>
<dd>
Class: f:Narcissist EquivalentTo: f:Person AND f:loves SELF <br />
f:Jeff f:loves f:Jeff <br />
Individual: f:Bill NOT f:Narcissist
</dd>
</dl>
<p>From this we can conclude that <name>Jeff</name>
belongs to
<name>Narcissist</name> and that, of course, <name>Bill</name>
does not.
</p>

<p>
In OWL we can also say some things about how properties combine, using
chains of object properties.
For example, we can say that <name>son</name>s and
<name>daughter</name>s are the same for both spouses, 
i.e., the <name>son</name>s and <name>daughter</name>s of an individual
include those of their <name>spouse</name>.
</p>

<dl class="tabbed">
<dt>Manchester Syntax</dt>
<dd>
SubObjectProperty: (f:hasSpouse f:hasSon) f:hasSon <br />
SubObjectProperty: (f:hasSpouse f:hasSon) f:hasSon
</dd>
</dl>

<p>
We can now conclude that <name>Emily</name> has the same 
<name>son</name>s and <name>daughter</name>s as <name>Jeff</name>:
</p>

<dl class="tabbed">
<dt>Manchester Syntax (consequence)</dt>
<dd>
f:Emily f:hasChild f:Jack <br />
f:Emily f:hasChild f:Ellen
</dd>
<dt>Functional-Style Syntax (consequence)</dt>
<dd> </dd>
<dt>RDF/XML Syntax (consequence)</dt>
<dd> </dd>
</dd>
</dl>

<h3>4.6 Conflicting Information</h3>
<p>
It is also possible to provide conflicting information to OWL.
For example, we could say that <name>John</name> has no
<name>child</name>ren who belong to <name>Woman</name>,
which conflicts with <name>John</name> having <name>Susan</name>
as a <name>daughter</name>.
</p>
<dl class="tabbed">
<dt>Manchester Syntax (conflict)</dt>
<dd>
Individual: f:John f:hasChild MAX 0 f:Woman
</dd>
<dt>Functional-Style Syntax (conflict)</dt>
<dd> </dd>
<dt>RDF/XML Syntax (conflict)</dt>
<dd> </dd>
</dd>
</dl>
<p>In the presence of conflicting information, determining
consequences in
OWL breaks down, so
it is generally not a good idea to have conflicting information.
There is no notion that OWL tools <em>have</em> to reject
conflicting
information.
However, most OWL tools will at least provide some mechanisms to
identify conflicting
information and allow users to resolve the conflict. </p>
<hr />

<h2><a name="ontologies"></a>5 Ontology Management</h2>

<h3>5.1 OWL Ontologies, Documents, and Namespaces</h3>

<p>
The information we have stated so far falls into two categories.  We
have stated general information about classes and properties related to
familial relationships and particular information about two linked
families.  In OWL general information about a topic is almost
always gathered into an ontology that is then used by various
applications.  We can also provide a name for OWL ontologies, which is
generally the place where the ontology document is placed in the web.
Particular information about a topic can also be placed in an ontology,
if it is used by different applications.
</p>

<dl class="tabbed">
<dt>Manchester Syntax</dt>
<dd>
Ontology: http://ex.com/owl/families
</dd>
</dl>

<p>
We place OWL ontologies into OWL documents, which are then placed into local
filesystems or on the World Wide Web.  Aside from containing an OWL
ontology, OWL documents also contain information about transforming the
short names used in OWL ontologies (e.g., f:Person) into IRIs, 
by providing the expansion for prefixes.
The IRI is then the concatention of the prefix expansion and the
reference.
</p>

<p>
In our example ontology we have used two prefixes, <name>f</name> and
<name>xsd</name>.   
The latter prefix has been used in compact names for
XML Schema datatypes, whose IRIs are fixed by the XML Schema
recommendation.
We thus must the standard expansion for <name>xsd</name>, which is 
<name>http://www.w3.org/2001/XMLSchema#</name>.
The expansion we pick for our the other prefix will affect the names of
the classes, properties, and individuals in our ontology, as well as the
name of the ontology itself.
If we are going to put the ontology on the web, we should pick an
expansion that is in some part of the web that we control, both so that
we are not using someone else's names by accident.
(Here we use a made-up name that no one controls.)
</p>

<dl class="tabbed">
<dt>Manchester Syntax</dt>
<dd>
Namespace: xsd = http://www.w3.org/2001/XMLSchema# <br />
Namespace: f = http://ex.com/owl/families# <br />
Namespace: g = http://ex2.com/owl/family.owl#
</dd>
</dl>

<h3>5.2 Imports</h3>

<p>
...
</p>

<p>
As the Semantic Web is distributed it is common for ontologies to use
different names for the same concept, property, or individual.
Several constructs in OWL can be used to state that different names
refer to the same concept, property, or individual, so, for example, we
could tie the names used in our ontology to the names used in an
imported ontology as follows:
</p>

<dl class="tabbed">
<dt>Manchester Syntax</dt>
<dd>
SameIndividual: f:male g:masculine <br />
SameIndividual: f:female g:feminine <br />
EquivalentClasses: f:Adult g:Grownup <br />
EquivalentObjectProperties: f:hasChild g:child <br />
EquivalentDataProperties: f:age g:age
</dd>
</dl>

<h3>5.3 Annotations</h3>

<hr />

<h2><a name="remaining">6 Remaining Constructs</a></h2>

<p>
There are a few other kinds of things that can be said in OWL, but that
do not fit into this example, including the following:
</p>
<ul>
<li> 
Several other XML Schema datatypes
[<a href="#ref-xml-schema-datatypes">XML Schema Datatypes</a>], most
notably <name>xsd:string</name> and 
<name>xsd:decimal</name>.
</li>
<li>
Some other datatype facets from XML Schema datatypes, including 
<name>xsd:length</name>, <name>xsd:minLength</name>, <name>xsd:maxLength</name>,
<name>xsd:totalDigits</name>, and <name>xsd:fractionDigits</name>.
</li>
<li>
Data properties in some, all, cardinality (at least, at most, exactly), and value
constructs.
</li>
<li>
Data properties as subproperties of,
or equivalent to, or disjoint from other data properties.
</li>
</ul>

<p>
Details on these constructs can be found in the OWL 1.1 Structural
Specification and Functional Syntax document 
[<a href="#ref-owl-1.1-specification">OWL 1.1 Specification</a>].
</p>

<hr />

<h2><a name="species">7 OWL Species</a></h2>

<p>
As we have seen, reasoning in OWL can be complicated.
The full story of reasoning in OWL is beyond the scope of this primer,
but there are some implications of reasoning that deserve treatement
here.
</p>

<h3>7.1 OWL Full</h3>

<p>
If we did not place further restrictions on what we can say in OWL, 
e.g., classes, properties, and even bits of syntax can be used as
individuals as in the Semantic Web language RDF, reasoning becomes
formally undecidable. 
Nevertheless, there is some utility in being able to do this, so there
is a mode of using OWL, called OWL Full that allows all this.
The price, of course, is that reasoning tools are hard to write and are
necessarily incomplete.
</p>

<h3>7.2 OWL DL</h3>

<p>
There are a set of reasonable restrictions, however, that make reasoning
in OWL decidable, and for which, moreover, there exist effective
reasoning tools.
This mode of using OWL is called OWL DL.
</p>

<p>
To allow effective reasoning tools, OWL DL limits the kinds of things
that can be said about certain properties.
Properties are said to be <em>composite</em> if they or their inverses
are transitive or have a property chain as a subproperty.
Properties that are composite or have a composite property as a
specialization of themselves or their inverses are not allowed to be 
functional, inverse functional, irreflexive, asymmetric, or disjoint
with any other property;
nor are they allowed to participated in cardinality or self conditions.
As well, there is a complex condition on how object property chains are
constructed to prevent loops related to object property chains.
OWL DL tools should recognize whether these conditions are violated in
an ontology.
</p>

<p>
OWL DL allows the same name to be used for any or all of a class, a
property, and an individual.
However, the different aspects of this name are not tied to one another,
so that if, for example, we said, perhaps by accident that
<name>Person</name> and <name>Man</name> were the same individual, they
would not also be equivalent classes.
</p>

<dl class="tabbed">
<dt>Manchester Syntax</dt>
<dd>
SameIndividual: f:Person f:Man
</dd>
</dl>

<p>
The above would not allow the conclusion of:
</p>

<dl class="tabbed">
<dt>Manchester Syntax (non-consequence in DL)</dt>
<dd>
EquivalentClasses: f:Person f:Man
</dd>
<dt>Functional-Style Syntax (non-consequence in DL)</dt>
<dd></dd>
<dt>RDF/XML Syntax (non-consequence in DL)</dt>
<dd></dd>
</dl>

<p>
OWL Full is formally stronger than OWL DL in this area (and in a few
other areas) so in OWL Full this conclusion could be drawn.
</p>

<h3>7.3 OWL Fragments</h3>

<p>
Reasoning in OWL DL is still difficult, and can take a very long time in
the worst case.
Certain fragments of OWL DL have been identified that guarantee better
worst-case performance for reasoning.
The document on OWL Fragments
[<a href="#ref-owl-1.1-fragments">OWL 1.1 Fragments</a>]
identifies and chacterizes several of
these fragments that have been shown to be useful in practice.
Staying within one of these fragments limits what we can say, but this
tradeoff can often be desirable when writing large ontologies,
particularly for important applications.
</p>

<hr /> 

<h2><a name="next">8 What to Read Next</a></h2>

<p>
This short primer can only scratch the surface of OWL.
There are many longer and more involved tutorials on OWL and how to use
OWL tools that can be found by searching on the Web.
</p>

<p>
This short primer is also not a normative definition of OWL.
The normative definition of the OWL syntax as well as informative
definitions of each OWL construct can be found in the
OWL 1.1 Structural
Specification and Functional Syntax document 
[<a href="#ref-owl-1.1-specification">OWL 1.1 Specification</a>].
</p>

<p>
For those interested in more formal documents,
the formal meaning of OWL can be found in the OWL 1.1 Semantics document 
[<a href="#ref-owl-1.1-semantics">OWL 1.1 Specification</a>],
and the mapping between OWL syntax and RDF triples can be found in 
the OWL 1.1 Mapping to RDF Graphs document 
[<a href="#ref-owl-1.1-rdf-mapping">OWL 1.1 RDF Mapping</a>].
</p>

<hr />

<h2><a name="example">8 The Complete Example</a></h2>

<p>
Here we include the complete example OWL ontology.
The ontology here is ordered in a commonly-used ordering, with ontology
information first, followed by information aabout properties, then
classes, then individuals.
Extra annotations have been added (NOT YET) to help explain the ontology.
</p>
<dl class="tabbed">
<dt>Manchester Syntax</dt>
<dd>
Namespace: xsd = http://www.w3.org/2001/XMLSchema# <br />
Namespace: f = http://ex.com/owl/families/# <br />
Namespace: g = http://ex2.com/owl/family.owl# <br />

Ontology: http://ex.com/owl/families/ <br />

Import: http://ex2.com/owl/family.owl <br />

ObjectProperty: f:hasWife domain: f:Person range: f:Person <br />
ObjectProperty: f:hasWife domain: f:Man range: f:Woman <br />
FunctionalDataProperty: f:hasWife <br />
InverseFunctionalDataProperty: f:hasWife <br />
IrreflexiveFunctionalDataProperty: f:hasWife <br />
AsymmetricFunctionalDataProperty: f:hasWife <br />

ObjectProperty: f:hasHusband inverseOf: f:hasWife <br />

ObjectProperty: f:hasChild domain: f:Person range f:Person <br />
ObjectProperty: f:hasSon SubPropertyOf: f:hasChild <br />
ObjectProperty: f:hasSon domain: f:Person range: f:Person <br />
ObjectProperty: f:hasSon domain: f:Parent range: Person AND f:hasGender f:male <br />
ObjectProperty: f:hasDaughter  SubPropertyOf: f:hasChild <br />
ObjectProperty: f:hasDaughter domain: f:Person range: f:Person <br />
ObjectProperty: f:hasDaughter domain: f:Parent range: Person AND f:hasGender f:female <br />
DisjointObjectProperties: f:hasSon f:hasDaughter <br />

SubObjectProperty: (f:hasSpouse f:hasSon) f:hasSon <br />
SubObjectProperty: (f:hasSpouse f:hasSon) f:hasSon

TransitiveObjectProperty: f:hasAncestor <br />
IrreflexiveObjectProperty: f:hasAncestor <br />
ObjectProperty: f:hasChild SubPropertyOf: inverseOf f:hasAncestor

SymmetricObjectProperty: f:hasSpouse <br />
IrreflexiveObjectProperty: f:hasSpouse <br />
ObjectProperty: f:hasWife SubPropertyOf: f:hasSpouse <br />

ObjectProperty: f:loves domain: f:Person <br />
ObjectProperty: f:hasWife SubPropertyOf: f:loves <br />

DataProperty: f:hasAge domain: f:Person range: xsd:integer <br />
FunctionalDataProperty: f:hasAge <br />

Class: f:Person <br />
Class: f:Person SubClassOf: f:hasAge EXACTLY 1 AND
                              f:hasGender EXACTLY 1 AND
			      f:hasGender ALL { f:male f:female } <br />
Class: f:Man SubClassOf: f:Person <br />
Class: f:Man EquivalentTo: f:Person AND f:hasGender VALUE f:male <br />
Class: f:Woman SubClassOf: f:Person <br />
Class: f:Woman EquivalentTo: f:Person AND f:hasGender VALUE f:female <br />
Class: f:Parent SubClassOf: f:Person <br />
Class: f:Parent EquivalentTo: f:Person AND f:hasChild MIN 1 f:Parent <br />

Class: Teenager SubClassOf: Person AND hasAge SOME xsd:integer &ge; "13"^^xsd:integer &lt; "20"^^xsd:integer <br />
Class: Adult SubClassOf: Person AND hasAge SOME xsd:integer &ge; "21"^^xsd:integer <br />
Class: Child SubClassOf: Person AND NOT ( hasAge SOME xsd:integer &ge; "21"^^xsd:integer ) <br />
Class: f:YoungChild EquivalentTo: NOT ( f:Teenager OR f:Adult ) <br />

Class: f:ReligiousMarriage DisjointWith: f:CivilMarriage <br />
Class: f:Marriage EquivalentTo: f:ReligiousMarriage OR f:CivilMarriage <br />
DisjointUnion: f:Marriage f:ReligiousMarriage f:CivilMarriage <br />

Class: f:Narcissist EquivalentTo: f:Person AND f:loves SELF <br />

f:John f:hasWife f:Mary <br />
f:John f:hasSon f:Bill <br />
f:Mary f:hasSon f:Bill <br />
f:John f:hasDaughter f:Susan <br />
f:Mary f:hasDaughter f:Susan <br />
f:John f:hasAge "33"^^xsd:integer <br />
f:Mary f:hasAge "31"^^xsd:integer <br />
f:Bill f:hasAge "13"^^xsd:integer <br />
f:Susan f:hasAge "8"^^xsd:integer
f:John f:hasGender f:male <br />
f:Mary f:hasGender f:female <br />
f:Bill f:hasGender f:male <br />
f:Susan f:hasGender f:female

f:Jeff f:hasWife f:Emily <br />
f:Jeff f:hasChild f:Jack <br />
f:Jeff f:hasChild f:Ellen <br />
f:Jeff f:hasAge "77"^^xsd:integer <br />
Individual: f:Ellen f:hasAge SOME xsd:integer &ge;
"15"^^xsd:integer &le; "21"^^xsd:integer <br />
Individual: f:Emily f:hasAge VALUE { "39"^^xsd:integer &le;
"49"^^xsd:integer } <br />
f:Jeff NOT f:hasAge "53"^^xsd:integer
Individual: f:Jeff f:hasChild EXACTLY 2

DifferentIndividuals: f:John f:Mary f:Bill f:Bill f:Susan <br />
DifferentIndividuals: f:Jeff f:Emily f:Jack f:Ellen f:Susan <br />
DifferentIndividuals: f:male f:female

f:Jeff f:loves f:Jeff <br />
Individual: f:Bill NOT f:Narcissist

SameIndividual: f:John f:Jack <br />

SameIndividual: f:male g:masculine <br />
SameIndividual: f:female g:feminine <br />
EquivalentClasses: f:Adult g:Grownup <br />
EquivalentObjectProperties: f:hasChild g:child <br />
EquivalentDataProperties: f:age g:age <br />

</dd>
<dt>Functional-Style Syntax</dt>
<dd>
ObjectPropertyDomain(f:hasWife f:Person)<br />
ObjectPropertyRange(f:hasWife f:Person)<br />
ObjectPropertyDomain(f:hasSon f:Person)<br />
ObjectPropertyRange(f:hasSon f:Person)<br />
ObjectPropertyDomain(f:hasDaughter f:Person)<br />
ObjectPropertyRange(f:hasDaughter f:Person)<br />
DataPropertyDomain(f:hasAge f:Person)<br />
DataPropertyRange(f:hasAge xsd:integer)
SubClassOf(f:Person 
    ObjectIntersectionOf(DataExactCardinality(1 f:hasAge) 
                         ObjectExactCardinality(1 f:hasGender) 
			 ObjectAllValuesFrom(f:hasGender ObjectOneOf(f:male f:female)))) <br />
EquivalentClasses(f:Man 
    ObjectIntersection(f:Person ObjectHasValue(f:hasGender f:male))) <br />
EquivalentClasses(f:Woman
    ObjectIntersection(f:Person ObjectHasValue(f:hasGender f:female))) <br />
EquivalentClasses(f:Parent
    ObjectIntersection(f:Person ObjectMinCardinality(1 f:hasChild)))

ObjectPropertyAssertion(f:John f:hasWife f:Mary) <br />
ObjectPropertyAssertion(f:John f:hasSon f:Bill) <br />
ObjectPropertyAssertion(f:Mary f:hasSon f:Bill) <br />
ObjectPropertyAssertion(f:John f:hasDaughter f:Susan) <br />
ObjectPropertyAssertion(f:Mary f:hasDaughter f:Susan) <br />
DataPropertyAssertion(f:John f:hasAge "33"^^xsd:integer) <br />
DataPropertyAssertion(f:Mary f:hasAge "31"^^xsd:integer) <br />
DataPropertyAssertion(f:Bill f:hasAge "13"^^xsd:integer) <br />
DataPropertyAssertion(f:Susan f:hasAge "8"^^xsd:integer)
</dd>
<dt>RDF/XML Syntax</dt>
<dd>
&lt;rdf:Description rdf:about="http://ex.com/owl/families#John"><br />
&nbsp;&nbsp;&lt;f:hasWife rdf:resource="http://ex.com/owl/families#Mary" /><br />
&nbsp;&nbsp;&lt;f:hasSon rdf:resource="http://ex.com/owl/families#Bill" /><br />
&nbsp;&nbsp;&lt;f:hasDaughter rdf:resource="http://ex.com/owl/families#Susan" /><br />
&nbsp;&nbsp;&lt;f:hasAge rdf:datatype="http://www.w3.org/2001/XMLSchema#integer">33&lt;/f:hasage><br />
&lt;/rdf:Description><br />
&lt;rdf:Description rdf:about="http://ex.com/owl/families#Mary"><br />
&nbsp;&nbsp;&lt;f:hasSon rdf:resource="http://ex.com/owl/families#Bill" /><br />
&nbsp;&nbsp;&lt;f:hasDaughter rdf:resource="http://ex.com/owl/families#Susan" /><br />
&nbsp;&nbsp;&lt;f:hasAge rdf:datatype="http://www.w3.org/2001/XMLSchema#integer">31&lt;/f:hasage><br />
&lt;/rdf:Description><br />
&lt;rdf:Description rdf:about="http://ex.com/owl/families#Bill"><br />
&nbsp;&nbsp;&lt;f:hasAge rdf:datatype="http://www.w3.org/2001/XMLSchema#integer">13&lt;/f:hasage><br />
&lt;/rdf:Description><br />
&lt;rdf:Description rdf:about="http://ex.com/owl/families#Susan"><br />
&nbsp;&nbsp;&lt;f:hasAge rdf:datatype="http://www.w3.org/2001/XMLSchema#integer">8&lt;/f:hasage><br />
&lt;/rdf:Description>
</dd>
</dl>

<hr />


<h2><a name="references"></a>References</h2>

<dl>
<dt><a id="ref-owl-1.1-fragments">[OWL 1.1 Fragments]</a></dt>
<dd>
<cite><a href="http://www.w3.org/2007/OWL/wiki/Tractable_Fragments">OWL
1.1 Web Ontology Language: Tractable Fragments</a></cite>.
Bernardo Cuenca Grau, 2007.
</dd>

<dt><a id="ref-owl-1.1-rdf-mapping">[OWL 1.1 RDF Mapping]</a></dt>
<dd>
<cite><a href="http://www.w3.org/2007/OWL/wiki/Mapping_to_RDF_Graphs">OWL
1.1 Web Ontology Language: Mapping to RDF Graphs</a></cite>.
Bernardo Cuenca Grau and Boris Motik, 2007.
</dd>

<dt><a id="ref-owl-1.1-semantics">[OWL 1.1 Semantics]</a></dt>
<dd>
<cite><a href="http://www.w3.org/2007/OWL/wiki/Semantics">OWL
1.1 Web Ontology Language: Model-Theoretic Semantics</a></cite>.
Bernardo Cuenca Grau and Boris Motik, 2007.
</dd>

<dt><a id="ref-owl-1.1-specification">[OWL 1.1 Specification]</a></dt>
<dd>
<cite><a href="http://www.w3.org/2007/OWL/wiki/Syntax">OWL 1.1 Web Ontology Language: Structural Specification and Functional-Style Syntax</a></cite>.
Peter F. Patel-Schneider, Ian Horrocks, and Boris Motik, 2007.
</dd>

<dt><a id="ref-xml-schema-datatypes">[XML Schema Datatypes]</a></dt>
<dd>
<cite><a href="http://www.w3.org/TR/xmlschema-2/">XML Schema Part 2: Datatypes Second Edition</a></cite>.
Paul V. Biron and Ashok Malhotra, eds.
W3C Recommendation 28 October 2004.
</dd>
</dl>
<hr />

</body>
</html>
